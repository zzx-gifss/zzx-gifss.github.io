<!DOCTYPE html>
<html lang="en">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>Z.X&#39;s Blog</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://iconfont.alicdn.com/t/290d75a4-c703-4c0b-a315-2afbe10affa2.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>Blog
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="" />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>Blog
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://ae01.alicdn.com/kf/Ud212830c10094a5e931133d617add4fdA.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Z.X</p>
    
    
      <p class="subtitle">岁月本无虞 未来尤可期</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
  </div>


  
  
  <h1 id="HTML单元"><a href="#HTML单元" class="headerlink" title="HTML单元"></a>HTML单元</h1><h2 id="你用过哪些H5标签和特性？"><a href="#你用过哪些H5标签和特性？" class="headerlink" title="你用过哪些H5标签和特性？"></a>你用过哪些H5标签和特性？</h2><p>video   视频播放</p>
<p>audio   音频播放</p>
<h2 id="meta中viewport是做什么的？"><a href="#meta中viewport是做什么的？" class="headerlink" title="meta中viewport是做什么的？"></a>meta中viewport是做什么的？</h2><h2 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h2><h2 id="HTML全局属性有哪些？"><a href="#HTML全局属性有哪些？" class="headerlink" title="HTML全局属性有哪些？"></a>HTML全局属性有哪些？</h2><p>class  元素设置类</p>
<p>data-*  自定义属性</p>
<p>id     元素的id</p>
<p>style  元素的css样式</p>
<p>title  元素相关的信息</p>
<p>lang   元素内容的语言  常见为lang=”English”</p>
<h2 id="src与href的区别"><a href="#src与href的区别" class="headerlink" title="src与href的区别"></a>src与href的区别</h2><h2 id="网络中使用最多的图片格式有哪些"><a href="#网络中使用最多的图片格式有哪些" class="headerlink" title="网络中使用最多的图片格式有哪些"></a>网络中使用最多的图片格式有哪些</h2><h1 id="CSS单元"><a href="#CSS单元" class="headerlink" title="CSS单元"></a>CSS单元</h1><h2 id="link-并行-和-import-串行-的区别"><a href="#link-并行-和-import-串行-的区别" class="headerlink" title="link(并行)和@import(串行)的区别"></a>link(并行)和@import(串行)的区别</h2><h2 id="垂直居中的方法"><a href="#垂直居中的方法" class="headerlink" title="垂直居中的方法"></a>垂直居中的方法</h2><h2 id="水平居中的方法"><a href="#水平居中的方法" class="headerlink" title="水平居中的方法"></a>水平居中的方法</h2><h2 id="opacity和rgba透明效果区别"><a href="#opacity和rgba透明效果区别" class="headerlink" title="opacity和rgba透明效果区别"></a>opacity和rgba透明效果区别</h2><h2 id="行内元素设置float之后会发生什么"><a href="#行内元素设置float之后会发生什么" class="headerlink" title="行内元素设置float之后会发生什么"></a>行内元素设置float之后会发生什么</h2><h2 id="px-rpx-em-rem-vw-vh的区别"><a href="#px-rpx-em-rem-vw-vh的区别" class="headerlink" title="px/rpx/em/rem/vw/vh的区别"></a>px/rpx/em/rem/vw/vh的区别</h2><h2 id="手写一个动画，你认为比较流畅的最大时间间隔为多少？"><a href="#手写一个动画，你认为比较流畅的最大时间间隔为多少？" class="headerlink" title="手写一个动画，你认为比较流畅的最大时间间隔为多少？"></a>手写一个动画，你认为比较流畅的最大时间间隔为多少？</h2><p>大部分设备刷新频率为60hz，即1s刷新60张图片，所以可以设置最大时间间隔为1000/60ms</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h3><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><h2 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h2><p>transition：过渡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transition-property:all&#x2F;&#x2F;应用效果的属性</span><br><span class="line">transition-duration:.3s;&#x2F;&#x2F;过渡效果持续时间</span><br><span class="line">transition-timing-function:liner&#x2F;&#x2F;匀速曲线</span><br><span class="line">transition-delay&#x2F;&#x2F;延迟</span><br><span class="line">transtion:all .3s ease .3s&#x2F;&#x2F;简写</span><br></pre></td></tr></table></figure>

<p>transform：旋转、缩放、移动或者倾斜</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2D</span><br><span class="line">transform:translateX()</span><br><span class="line">transform:rotateX()</span><br><span class="line">transform-origin:0px 0px &#x2F;&#x2F;中心点</span><br><span class="line">transform：scale(2)&#x2F;&#x2F;等比例放大</span><br><span class="line"></span><br><span class="line">3D</span><br><span class="line">transform-style:preserve-3d</span><br><span class="line">&#x2F;&#x2F;写给父级，子元素开启3D</span><br><span class="line">perspective:500px</span><br><span class="line">&#x2F;&#x2F;透视</span><br><span class="line">transform:translate3d(x,y,z)</span><br><span class="line">transform:rotated3d(x,y,z,deg)</span><br></pre></td></tr></table></figure>

<p>animation：动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@keyframs donghua&#123;</span><br><span class="line">	0%&#123;&#125;</span><br><span class="line">	25%&#123;&#125;</span><br><span class="line">	75%&#123;&#125;</span><br><span class="line">	100%&#123;&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;定义动画</span><br><span class="line"></span><br><span class="line">animation-name:donghua</span><br><span class="line">animation-duration:.3s</span><br><span class="line">animation-timing-function:ease</span><br><span class="line">aniamtion-iteration-count:1&#x2F;&#x2F;动画重复次数</span><br><span class="line">animation-direction:normal&#x2F;&#x2F;动画方向</span><br><span class="line">animation-fill-mode:backwords&#x2F;&#x2F;动画结束后回到起始状态</span><br><span class="line">aniamtion-play-state:running&#x2F;&#x2F;动画是否运动</span><br></pre></td></tr></table></figure>

<p>gradient：渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:　linear-gradient（方向，　颜色，　颜色，．．）</span><br></pre></td></tr></table></figure>

<p>实现渐变图片</p>
<p>shadow：阴影</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-shadow:#000(阴影颜色) 4px 4px 5px</span><br></pre></td></tr></table></figure>

<p>border-radius：圆角</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius:25px</span><br></pre></td></tr></table></figure>

<h2 id="block元素和inline元素的区别"><a href="#block元素和inline元素的区别" class="headerlink" title="block元素和inline元素的区别"></a>block元素和inline元素的区别</h2><h2 id="CSS继承、层叠"><a href="#CSS继承、层叠" class="headerlink" title="CSS继承、层叠"></a>CSS继承、层叠</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h3><p>BFC叫块级格式化范围，它决定了元素如何对其内容定位，以及与其他元素的关系和相互作用。</p>
<h3 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h3><p>1.内部的Box会在垂直方向，一个接一个地放置。</p>
<p>2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p>
<p>3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p>
<p>4.BFC的区域不会与float box重叠。</p>
<p>5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
<p>6.计算BFC的高度时，浮动元素也参与计算</p>
<h3 id="怎么产生BFC"><a href="#怎么产生BFC" class="headerlink" title="怎么产生BFC"></a>怎么产生BFC</h3><p>1.根元素</p>
<p>2.float不为none</p>
<p>3.position设置为absolute或者fixed</p>
<p>4.display取值只能为inline-block/tabel-cell/table-caption/flex/inline-flex</p>
<p>5.overflow不能为visible</p>
<h3 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h3><ol>
<li>利用BFC避免上下margin重合</li>
</ol>
<p>下面来看一个例子：</p>
<p>HTML, XML</p>
<head>

<p>    <meta charset="UTF-8"></p>
<p>    <meta http-equiv="X-UA-Compatible" content="IE=edge"></p>
<p>    <meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
  <title>Document</title>

<p>    <style></p>
<p>​    * {</p>
<p>​      margin: 0;</p>
<p>​      padding: 0;</p>
<p>​    }</p>
<p>​    p {</p>
<p>​      color: #f55;</p>
<p>​      background: yellow;</p>
<p>​      width: 200px;</p>
<p>​      line-height: 100px;</p>
<p>​      text-align: center;</p>
<p>​      margin: 30px;</p>
<p>​    }</p>
<p>  </style></p>
</head>

<body>

<p>    <p class="d1">p1</p></p>
<p>    <p class="d2">p2</p></p>
</body>

<p>对于上述的例子，大家可以在浏览器查看一下，可以发现p1与p2上下margin值为30px，为了让上下margin不重叠，可以将某一个p变成一个BFC，我们展示一下将p2变为BFC。</p>
<p>HTML, XML</p>
<head>

<p>    <meta charset="UTF-8"></p>
<p>    <meta http-equiv="X-UA-Compatible" content="IE=edge"></p>
<p>    <meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
  <title>Document</title>

<p>    <style></p>
<p>​    * {</p>
<p>​      margin: 0;</p>
<p>​      padding: 0;</p>
<p>​    }</p>
<p>​    p {</p>
<p>​      color: #f55;</p>
<p>​      background: yellow;</p>
<p>​      width: 200px;</p>
<p>​      line-height: 100px;</p>
<p>​      text-align: center;</p>
<p>​      margin: 30px;</p>
<p>​    }</p>
<p>​    div{</p>
<p>​      display: inline-block;</p>
<p>​    }</p>
<p>  </style></p>
</head>

<body>

<p>    <p class="d1">p1</p></p>
<p>    <div></p>
<p>        <p class="d2">p2</p></p>
  </div>

</body>

<p>用一个div将p2包裹起来，给div设置能够将div激活成为BFC的属性，即上述文章中产生BFC的五条规则，写随便一条即可。此时再打开浏览器看，p1和p2的上下margin变成了60px。</p>
<ol>
<li>自适应两栏布局</li>
</ol>
<p>HTML, XML</p>
<!DOCTYPE html>

<html lang="en">

<head>

<p>    <meta charset="UTF-8"></p>
<p>    <meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
<p>    <meta http-equiv="X-UA-Compatible" content="ie=edge"></p>
  <title>Document</title>

</head>

<style>

  *{

​    margin: 0;

​    padding: 0;

  }

  body {

​    width: 100%;

​    position: relative;

  }

  .left {

​    width: 100px;

​    height: 150px;

​    float: left;

​    background: rgb(139, 214, 78);

​    text-align: center;

​    line-height: 150px;

​    font-size: 20px;

  }

  .right {

​    height: 300px;

​    background: rgb(170, 54, 236);

​    text-align: center;

​    line-height: 300px;

​    font-size: 40px;

  }

</style>

<body>

<p>    <div class="left">LEFT</div></p>
<p>    <div class="right">RIGHT</div></p>
</body>

</html>

<p>上述代码在浏览器中显示为divleft和divright的左侧都贴近了body，为了不让divleft覆盖divright，可以将divright设置为一个BFC，即给divright添加任何一条产生BFC的属性。改动如下：</p>
<p>CSS</p>
<p> .right {</p>
<p>​    overflow: hidden;</p>
<p>​    height: 300px;</p>
<p>​    background: rgb(170, 54, 236);</p>
<p>​    text-align: center;</p>
<p>​    line-height: 300px;</p>
<p>​    font-size: 40px;</p>
<p>  }</p>
<p>激活divright后，请大家再查看页面内容，此时就完成了一个自适应的两栏布局。</p>
<ol>
<li>清除浮动</li>
</ol>
<p>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清楚浮动。代码如下：</p>
<p>HTML, XML</p>
<!DOCTYPE html>

<html lang="en">

<head>

<p>    <meta charset="UTF-8"></p>
<p>    <meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
<p>    <meta http-equiv="X-UA-Compatible" content="ie=edge"></p>
  <title>清除浮动</title>

</head>

<style>

  .par {

​    border: 5px solid rgb(91, 243, 30);

​    width: 300px;

  }

  

  .child {

​    border: 5px solid rgb(233, 250, 84);

​    width:100px;

​    height: 100px;

​    float: left;

  }

</style>

<body>

<p>    <div class="par"></p>
<p>        <div class="child"></div></p>
<p>        <div class="child"></div></p>
  </div>

</body>

</html>

<p>上述代码在浏览器中打开，发现父元素divpar高度塌陷，此时只需要将父元素变为BFC即可，改动如下：</p>
<p>CSS</p>
<p>.par {</p>
<p>​    overflow: hidden;</p>
<p>​    border: 5px solid rgb(91, 243, 30);</p>
<p>​    width: 300px;</p>
<p>  }</p>
<h1 id="JS单元"><a href="#JS单元" class="headerlink" title="JS单元"></a>JS单元</h1><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h3 id="reduce实现"><a href="#reduce实现" class="headerlink" title="reduce实现"></a>reduce实现</h3><h3 id="toString-amp-split"><a href="#toString-amp-split" class="headerlink" title="toString&amp;split"></a>toString&amp;split</h3><h3 id="join-amp-split"><a href="#join-amp-split" class="headerlink" title="join &amp; split"></a>join &amp; split</h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="Set去重"><a href="#Set去重" class="headerlink" title="Set去重"></a>Set去重</h3><h3 id="指针法去重"><a href="#指针法去重" class="headerlink" title="指针法去重"></a>指针法去重</h3><h3 id="利用indexOf去重"><a href="#利用indexOf去重" class="headerlink" title="利用indexOf去重"></a>利用indexOf去重</h3><h3 id="利用includes去重"><a href="#利用includes去重" class="headerlink" title="利用includes去重"></a>利用includes去重</h3><h3 id="使用filter去重"><a href="#使用filter去重" class="headerlink" title="使用filter去重"></a>使用filter去重</h3><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h3><h2 id="DOM-BOM"><a href="#DOM-BOM" class="headerlink" title="DOM/BOM"></a>DOM/BOM</h2><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="es6新增的数据类型有哪些"><a href="#es6新增的数据类型有哪些" class="headerlink" title="es6新增的数据类型有哪些"></a>es6新增的数据类型有哪些</h3><h3 id="var、let、const区别"><a href="#var、let、const区别" class="headerlink" title="var、let、const区别"></a>var、let、const区别</h3><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><h3 id="promise的用法和几种状态"><a href="#promise的用法和几种状态" class="headerlink" title="promise的用法和几种状态"></a>promise的用法和几种状态</h3><h3 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h3><h2 id="严格模式和普通模式区别"><a href="#严格模式和普通模式区别" class="headerlink" title="严格模式和普通模式区别"></a>严格模式和普通模式区别</h2><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h3><h3 id="JSON实现深拷贝"><a href="#JSON实现深拷贝" class="headerlink" title="JSON实现深拷贝"></a>JSON实现深拷贝</h3><h2 id="async和defer的区别"><a href="#async和defer的区别" class="headerlink" title="async和defer的区别"></a>async和defer的区别</h2><h2 id="JS事件轮询机制"><a href="#JS事件轮询机制" class="headerlink" title="JS事件轮询机制"></a>JS事件轮询机制</h2><h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖有两个版本，分别为防抖延迟执行版本和防抖立即执行版本。</p>
<p><strong>防抖立即执行</strong></p>
<p><img src="https://uploader.shimo.im/f/rpZO6l4S1iA8S8XP.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/rpZO6l4S1iA8S8XP.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>相应的，我们结合代码来看一下：</p>
<p>JavaScript</p>
<p>function debounce(func,wait) {</p>
<p>  let timeout = null;</p>
<p>  return function () {</p>
<p>​    let context = this;</p>
<p>​    let args = arguments;</p>
<p>​    if (timeout) clearTimeout(timeout);</p>
<p>​    let callNow = !timeout;</p>
<p>​    timeout = setTimeout(() =&gt; {</p>
<p>​      timeout = null;</p>
<p>​    }, wait)</p>
<p>​    if (callNow) func.apply(context, args)</p>
<p>  }</p>
<p>}</p>
<p>function change(){</p>
<p>  console.log(1)</p>
<p>}</p>
<p>div.onclick = debounce(change,1000)</p>
<p>所谓的立即执行，就是点击div就会立刻执行change函数，并且打印1。先分析一下debounce函数，他接受两个参数，分别为change函数和1000ms，首先设置一个变量timeout为null，然后return一个新的函数，当我们点击div的时候，实际上的事件回调函数就为这个return出来的函数，所以此时的this即为div，arguments即为事件回调函数所接收的参数e。判断当前有没有设置timeout的值，此时值为null，所以并没有执行if后边的语句。设置变量callNow为!timeout，即此时callNow的值为true，然后将一个延时器赋值给timeout，判断callNow的值，因为callNow此时为true，所以执行func.apply，改变func(change函数)的this指向，指向div。这样就完成了第一次的防抖。当你在设置的1000ms内再次点击div，相当于直接执行了return出来的函数，即首先获取this，获取arguments，判断timeout的值，此时timeout经过上一轮的逻辑他已经有一个延时器了，所以可以进入到if判断中，清除延时器，然后再次获取callNow的值，虽然timeout延时器被清除，但是!timeout绝不是true，不信你可以打印一下。所以callNow的值也就不为true，然后重新给timeout装载延时器，最后判断callNow的值，现在callNow不为true，所以进不去if判断，也就不能执行func(change函数)。</p>
<p><strong>防抖延迟执行</strong></p>
<p><img src="https://uploader.shimo.im/f/QBOLd34hDnD1F69n.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/QBOLd34hDnD1F69n.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>防抖延迟执行跟立即执行的区别在于第一次触发防抖函数，得等到设定的时间才会执行一次回调函数change。</p>
<p>代码如下：</p>
<p>JavaScript</p>
<p>function debounce(func, wait) {</p>
<p>  let timeout = null;</p>
<p>  return function () {</p>
<p>​    let context = this;</p>
<p>​    let args = arguments;</p>
<p>​    if (timeout) clearTimeout(timeout);</p>
<p>​    </p>
<p>​    timeout = setTimeout(() =&gt; {</p>
<p>​      func.apply(context, args)</p>
<p>​    }, wait);</p>
<p>  }</p>
<p>}</p>
<p>function change(){</p>
<p>  console.log(1)</p>
<p>}</p>
<p>div.onclick = debounce(change,1000)</p>
<p><strong>防抖使用场景</strong></p>
<p>Plain  Text</p>
<p>多次触发某一个事件，只关注最后一次或者第一次的结果的场景</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流分为时间戳版本和延时器版本</p>
<p><strong>节流时间戳版本</strong></p>
<p><img src="https://uploader.shimo.im/f/g5TPJVcRMPCUN3MU.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/g5TPJVcRMPCUN3MU.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>代码如下：</p>
<p>JavaScript</p>
<p>function throttle(func, wait) {</p>
<p>  let previous = 0;</p>
<p>  return function() {</p>
<p>​    let now = Date.now();</p>
<p>​    let context = this;</p>
<p>​    let args = arguments;</p>
<p>​    if (now - previous &gt; wait) {</p>
<p>​      func.apply(context, args);</p>
<p>​      previous = now;</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>function change(){</p>
<p>  console.log(1)</p>
<p>}</p>
<p>div.onclick = throttle(change,1000)</p>
<p><strong>节流延时器版本</strong></p>
<p><img src="https://uploader.shimo.im/f/OyfTwYVxTymPqUt4.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/OyfTwYVxTymPqUt4.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>代码如下：</p>
<p>JavaScript</p>
<p>function throttle(func, wait) {</p>
<p>  let timeout;</p>
<p>  return function() {</p>
<p>​    let context = this;</p>
<p>​    let args = arguments;</p>
<p>​    if (!timeout) {</p>
<p>​      timeout = setTimeout(() =&gt; {</p>
<p>​        timeout = null;</p>
<p>​        func.apply(context, args)</p>
<p>​      }, wait)</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>function change(){</p>
<p>  console.log(1)</p>
<p>}</p>
<p>div.onclick = throttle(change,1000)</p>
<p><strong>节流使用场景</strong></p>
<p>Plain  Text</p>
<p>多次触发事件，保证一定时间内必须产生结果的场景</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="手写ajax封装"><a href="#手写ajax封装" class="headerlink" title="手写ajax封装"></a>手写ajax封装</h3><h2 id="事件代理-事件委托"><a href="#事件代理-事件委托" class="headerlink" title="事件代理(事件委托)"></a>事件代理(事件委托)</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><h3 id="事件捕捉"><a href="#事件捕捉" class="headerlink" title="事件捕捉"></a>事件捕捉</h3><h3 id="事件代理-事件委托-1"><a href="#事件代理-事件委托-1" class="headerlink" title="事件代理(事件委托)"></a>事件代理(事件委托)</h3><h3 id="阻止事件冒泡和默认事件"><a href="#阻止事件冒泡和默认事件" class="headerlink" title="阻止事件冒泡和默认事件"></a>阻止事件冒泡和默认事件</h3><h2 id="原型、原型链、继承"><a href="#原型、原型链、继承" class="headerlink" title="原型、原型链、继承"></a>原型、原型链、继承</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h2 id="发布订阅者模式和观察者模式"><a href="#发布订阅者模式和观察者模式" class="headerlink" title="发布订阅者模式和观察者模式"></a>发布订阅者模式和观察者模式</h2><h3 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h3><h3 id="发布订阅模式（Pub-Sub-Pattern）"><a href="#发布订阅模式（Pub-Sub-Pattern）" class="headerlink" title="发布订阅模式（Pub-Sub Pattern）"></a>发布订阅模式（Pub-Sub Pattern）</h3><h3 id="观察者模式和发布订阅模式有什么区别？"><a href="#观察者模式和发布订阅模式有什么区别？" class="headerlink" title="观察者模式和发布订阅模式有什么区别？"></a>观察者模式和发布订阅模式有什么区别？</h3><h3 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h3><h3 id="发布订阅模式实现"><a href="#发布订阅模式实现" class="headerlink" title="发布订阅模式实现"></a><strong>发布订阅模式实现</strong></h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><h2 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h2><h3 id="call基本使用"><a href="#call基本使用" class="headerlink" title="call基本使用"></a>call基本使用</h3><h3 id="apply基本使用"><a href="#apply基本使用" class="headerlink" title="apply基本使用"></a>apply基本使用</h3><h3 id="bind基本使用"><a href="#bind基本使用" class="headerlink" title="bind基本使用"></a>bind基本使用</h3><h3 id="手写bind函数"><a href="#手写bind函数" class="headerlink" title="手写bind函数"></a>手写bind函数</h3><p>Function.prototype.myBind = function (context) {</p>
<p>  if (typeof this !== “function”) {</p>
<p>​    throw new TypeError(“Error”);</p>
<p>  }</p>
<p>  var args = […arguments].slice(1);</p>
<p>  var that = this;</p>
<p>  return function Fn() {</p>
<p>​    return that.apply(context,args.concat(…arguments)</p>
<p>​    );</p>
<p>  };</p>
<p>};</p>
<p>var person = {</p>
<p>  name : “Edward”</p>
<p>}</p>
<p>var obj = {</p>
<p>  print : function(age){</p>
<p>​    console.log(this.name, age)</p>
<p>  }</p>
<p>}</p>
<p>obj.print.myBind(person , 30)()</p>
<p>//call实现bind</p>
<p>Function.prototype.myBind = function (context) {</p>
<p>  if (typeof this !== “function”) {</p>
<p>​    throw new TypeError(“Error”);</p>
<p>  }</p>
<p>  var args = […arguments].slice(1);</p>
<p>  var that = this;</p>
<p>  return function Fn() {</p>
<p>​    return that.call(context,…args);</p>
<p>  };</p>
<p>};</p>
<p>var person = {</p>
<p>  name : “Edward”</p>
<p>}</p>
<p>var obj = {</p>
<p>  print : function(age, hh){</p>
<p>​    console.log(this.name, age , hh)</p>
<p>  }</p>
<p>}</p>
<p>obj.print.myBind(person , 30 , 11)()</p>
<p>上述两种代码逻辑一样，此处只讲第一种call实现bind。</p>
<p>首先将实现的myBind写道函数类的原型上，这样所有函数都可以调用myBind，然后当一个函数调用myBind时，判断this(调用myBind的对象)是否为函数，因为只有函数才能调用bind，所以我们的myBind也要遵循。然后将调用myBind函数时传递进来的参数从arguments中取出，具体arguments中有什么读者可以自行打印即知。将当前调用myBind的对象即this保存到that中方便之后使用。因为bind函数调用之后会返回一个函数，所以myBind最终也要return一个新的函数出来，我们用call实现myBind，需要知道call必须有调用它的对象，此时调用myBind的对象即为调用call的对象，所以此处可以用到that。call要绑定新的this指向，这个指向就是myBind接收的第一个参数。然后传入call中的参数即为传入myBind中除了第一个参数之外的其他参数，至此myBind实现完毕。代价可以对照代码和调用myBind以及文字说明去理解以下，有点难，请耐心。</p>
<h2 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h2><p>升序冒泡： 两次循环，相邻元素两两比较，如果前面的大于后面的就交换位置 </p>
<p>降序冒泡： 两次循环，相邻元素两两比较，如果前面的小于后面的就交换位置   </p>
<p>JavaScript</p>
<p>// 升序冒泡 </p>
<p>function maopao(arr) {</p>
<p>  const array = […arr]</p>
<p>  for (let i = 0, len = array.length; i &lt; len - 1; i++) {</p>
<p>​    for (let j = i + 1; j &lt; len; j++) {</p>
<p>​      if (array[i] &gt; array[j]) {</p>
<p>​        let temp = array[i]</p>
<p>​        array[i] = array[j]</p>
<p>​        array[j] = temp</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>  return array</p>
<p>}</p>
<h2 id="JS中栈和堆的区别"><a href="#JS中栈和堆的区别" class="headerlink" title="JS中栈和堆的区别"></a>JS中栈和堆的区别</h2><h2 id="js中的变量类型与栈和堆的关系"><a href="#js中的变量类型与栈和堆的关系" class="headerlink" title="js中的变量类型与栈和堆的关系"></a>js中的变量类型与栈和堆的关系</h2><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h1 id="服务端单元"><a href="#服务端单元" class="headerlink" title="服务端单元"></a>服务端单元</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h3><p>Plain  Text</p>
<p>协议不同：如<a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> 和 <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>域名不同：如<a target="_blank" rel="noopener" href="http://www.baidu.com和/">http://www.baidu.com和</a> <a target="_blank" rel="noopener" href="https://www.xiaodu.com/">https://www.xiaodu.com</a></p>
<p>端口不同：如<a href="http://www.baidu.com:80和http://www.baidu.com:3000">http://www.baidu.com:80和http://www.baidu.com:3000</a></p>
<p>前端常用跨域解决方案常见如下：</p>
<p>Plain  Text</p>
<p>cros跨域</p>
<p>jsonp跨域</p>
<p>proxy代理跨域</p>
<h3 id="cros跨域及解决"><a href="#cros跨域及解决" class="headerlink" title="cros跨域及解决"></a>cros跨域及解决</h3><p>如出现cros跨域，浏览器会报错，示例如下：</p>
<p><img src="https://uploader.shimo.im/f/tiTlajHq3yVjEPBQ.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/tiTlajHq3yVjEPBQ.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>对于这种跨域比较好的解决方式就是给服务器设置允许跨域的字段，一般需要设置如下几个字段，以express框架来说，设置允许cros跨域响应头：</p>
<p>JavaScript</p>
<p>app.all(“*” , function(req,res,next){</p>
<p> res.header(‘Access-Control-Allow-Origin’ , “*”)</p>
<p> res.header(‘Access-Control-Allow-Headers’ , ‘Content-Type,Content-length,Authorization,Accept,X-Requested-With,yourHeaderFeild’);</p>
<p> res.header(‘Access-Control-Allow-Methods’ , ‘PUT,POST,GET,DELETE,OPTIONS’);</p>
<p> if(req.method == ‘OPTIONS’){</p>
<p>  res.send(200)</p>
<p> }</p>
<p> else{</p>
<p>  next()</p>
<p> }</p>
<p>})</p>
<p>上述代码中设置细则如下：</p>
<p>Plain  Text</p>
<p>Access-Control-Allow-Origin：设置允许cros跨域的网址</p>
<p>Access-Control-Allow-Headers：设置允许cros跨域的请求头部</p>
<p>Access-Control-Allow-Methods：设置允许cros跨域的请求方式</p>
<h3 id="jsop跨域及解决"><a href="#jsop跨域及解决" class="headerlink" title="jsop跨域及解决"></a>jsop跨域及解决</h3><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<p>总结：</p>
<ol>
<li><p>对于不支持cros跨域的浏览器，只能使用jsonp</p>
</li>
<li><p>jsonp不会触发同源策略</p>
</li>
<li><p>通过script发送ajax请求</p>
</li>
</ol>
<p>前端代码如下：</p>
<p>JavaScript</p>
<p>    <script></p>
<p>​    var script = document.createElement(‘script’);</p>
<p>​    script.type = ‘text/javascript’;</p>
<p>​    // 传参并指定回调执行函数为onBack</p>
<p>​    script.src = ‘<a target="_blank" rel="noopener" href="http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&#39;">http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&#39;</a>;</p>
<p>​    document.head.appendChild(script);</p>
<p>​    // 回调执行函数</p>
<p>​    function onBack(res) {</p>
<p>​      alert(JSON.stringify(res));</p>
<p>​    }</p>
<p>  </script></p>
<p>后端代码如下：</p>
<p>JavaScript</p>
<p>var querystring = require(‘querystring’);</p>
<p>var http = require(‘http’);</p>
<p>var server = http.createServer(function (req, res) {</p>
<p>  var params = querystring.parse(req.url.split(‘?’)[1]);</p>
<p>  var fn = params.callback;</p>
<p>  res.writeHead(200, { ‘Content-Type’: ‘text/javascript’ });</p>
<p>  res.write(fn + ‘(‘ + JSON.stringify(params) + ‘)’);</p>
<p>  res.end();</p>
<p>})</p>
<p>server.listen(‘8080’);</p>
<h3 id="proxy代理跨域-最常见"><a href="#proxy代理跨域-最常见" class="headerlink" title="proxy代理跨域(最常见)"></a>proxy代理跨域(最常见)</h3><p>使用vue开发的时候，可以使用vue脚手架自带的http-proxy代理程序进行跨域。</p>
<p>步骤：</p>
<ol>
<li>在vue脚手架中新增配置文件vue.config.js文件，添加一个新的配置项，如下：</li>
</ol>
<p>JavaScript</p>
<p>module.exports = {</p>
<p>​    devServer:{</p>
<p>​        proxy:{</p>
<p>​            ‘/api’:{</p>
<p>​                target:’<a target="_blank" rel="noopener" href="http://localhost:3000/&#39;//%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A33000">http://localhost:3000/&#39;//自己的服务器端口3000</a></p>
<p>​                changeOrigin:true //打开跨域</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>上述代码中设置了一个接口/api，这个接口作为自己的服务器的代理服务器，即访问这个接口就如访问<a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a></p>
<p>然后我们需要将这个/api作为我们提交数据的默认地址，即在vue项目的mian.js文件中设置如下代码，此处以axios为例：</p>
<p>Plain  Text</p>
<p>axios.defalts.baseURL = “/api”</p>
<h2 id="node事件轮询机制"><a href="#node事件轮询机制" class="headerlink" title="node事件轮询机制"></a>node事件轮询机制</h2><p>node事件轮询和js事件轮询非常的相似，但是也有区别，如下：</p>
<p>Plain  Text</p>
<p>1.node中无window对象，所以也就没有MutationObserver微任务和requestAnimationFrame宏任务</p>
<p>2.node中新增了setImmediate宏任务和process.nextTick微任务</p>
<p>node和js共有的宏微任务如下：</p>
<p>Plain  Text</p>
<p>1.input/output宏任务</p>
<p>2.setTimeout</p>
<p>3.setInterval</p>
<p>4.Promise</p>
<p>下面我们结合一个实例来看一下node中的执行顺序：</p>
<p>JavaScript</p>
<p>console.log(1)</p>
<p>process.nextTick(()=&gt;{</p>
<p>  console.log(2)</p>
<p>})</p>
<p>setImmediate(()=&gt;{</p>
<p>  console.log(3)</p>
<p>})</p>
<p>setTimeout(()=&gt;{</p>
<p>  console.log(4)</p>
<p>})</p>
<p>new Promise((resolve)=&gt;{</p>
<p>  console.log(5)</p>
<p>  resolve()</p>
<p>}).then(()=&gt;{</p>
<p>  console.log(6)</p>
<p>})</p>
<p>上述代码执行顺序如下：</p>
<p>Plain  Text</p>
<p>1.console.log(1)执行             1</p>
<p>2.process加入微任务队列</p>
<p>3.setImmediate加入宏任务队列</p>
<p>4.setTimeout加入宏任务队列</p>
<p>5.Promise主体执行                 5</p>
<p>6.then加入微任务队列                  </p>
<p>7.执行微任务队列中的procsss、then   2 6</p>
<p>8.执行setTimeout                 4</p>
<p>9.执行setImmediate               3</p>
<p>//1 5 2 6 4 3 </p>
<p>node新增api使用方式</p>
<p>Plain  Text</p>
<p>process.nextTick   微任务，不管什么时候进入微任务，都会在第一位执行。</p>
<p>setImmediate   宏任务，在一轮事件轮询之后执行</p>
<p>所以结合执行顺序和使用方式，可知process在then之前执行，不管它什么时候加入微任务队列，setImmediate在上述例子中在setTimeout之后执行，因为他必须在一轮事件轮询之后才能执行，不管他的等待时间是多少。</p>
<h2 id="node中的线程和进程"><a href="#node中的线程和进程" class="headerlink" title="node中的线程和进程"></a>node中的线程和进程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>Plain  Text</p>
<p>当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。一个进程又是由多个线程所组成的。</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>Plain  Text</p>
<p>线程是程序中的一个执行流，每个线程都有自己的专有寄存器但代码区是共享的，即不同的线程可以执行同样的函数。</p>
<h3 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h3><p>Plain  Text</p>
<p>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p>
<h3 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h3><p>Plain  Text</p>
<p>可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率</p>
<h3 id="多线程的不利方面"><a href="#多线程的不利方面" class="headerlink" title="多线程的不利方面"></a>多线程的不利方面</h3><p>Plain  Text</p>
<p>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多 </p>
<p>多线程需要协调和管理，所以需要CPU时刻跟踪线程</p>
<p>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题</p>
<p>线程太多会导致控制太复杂，最终可能造成很多Bu</p>
<h3 id="多线程与单线程的区别"><a href="#多线程与单线程的区别" class="headerlink" title="多线程与单线程的区别"></a>多线程与单线程的区别</h3><p>Plain  Text</p>
<p>生活举例：你早上上班，正要打卡的时候，手机响了。。你如果先接了电话，等接完了，在打卡，就是单线程。如果你一手接电话，一手打卡。就是多线程。2件事的结果是一样的。。你接了电话且打了卡。</p>
<h3 id="node实现多线程"><a href="#node实现多线程" class="headerlink" title="node实现多线程"></a>node实现多线程</h3><p>nodejs本身运行采用的是单线程，但是node支持开启多线程解决问题，所以本节主要讲述一下node实现多线程的过程。</p>
<p>我们拿一个斐波那契数列作为测试用例，对比不开启和开启多线程的运算速度。</p>
<p><strong>首先是正常情况</strong></p>
<p>JavaScript</p>
<p>const arr = [44, 42, 43, 44]</p>
<p>function fibonacci (n) {</p>
<p> return n === 0</p>
<p>  ? 0</p>
<p>  : n === 1</p>
<p>   ? 1</p>
<p>   : fibonacci(n - 1) + fibonacci(n - 2)</p>
<p>}</p>
<p>function handle (item) {</p>
<p> return new Promise((resolve, reject) =&gt; {</p>
<p>  fibonacci(item)</p>
<p>  return resolve(item)</p>
<p> })</p>
<p>}</p>
<p>(async function main () {</p>
<p> console.time(‘main’)</p>
<p> var result = await Promise.all(arr.map(handle))</p>
<p> console.log(result)</p>
<p> console.timeEnd(‘main’)</p>
<p>})()</p>
<p>上述代码中我们规定了一个数组，数组的每一项代表斐波那契数列传入的值n，定义一个async函数，使用Promise.all方法将多个promise合并成为一个promise。使用map方法遍历arr数组，将数组的每一项传递到handle函数的形参n中。handle函数执行斐波那契数列，执行完毕后调用resolve。这样map遍历四次，handle函数即执行四次，相应的也完成了四次斐波那契数列的执行。最后的到运行时间为17.585s左右。</p>
<p><strong>开启多线程</strong></p>
<p>JavaScript</p>
<p>const cluster = require(‘cluster’); //引入开启多线程的模块</p>
<p>function fibonacci(n) {</p>
<p>  return n === 0</p>
<p>​    ? 0</p>
<p>​    : n === 1</p>
<p>​      ? 1</p>
<p>​      : fibonacci(n - 1) + fibonacci(n - 2)</p>
<p>}</p>
<p>if (cluster.isMaster) {  //判断是否为主进程</p>
<p>  const arr = [44, 42, 43, 44]</p>
<p>  console.time(‘main’)</p>
<p>  let endTaskNum = 0;</p>
<p>  for(let i = 0 ; i &lt; 4 ; i++){  //使用4个子进程</p>
<p>​    const worker = cluster.fork()</p>
<p>​    worker.send(<code>$&#123;arr[i]&#125;</code>)  //每个子进程处理一个arr元素</p>
<p>  }</p>
<p>  cluster.on(‘message’ , (worker)=&gt;{  //主进程通信</p>
<p>​    endTaskNum++;</p>
<p>​    if(endTaskNum === 4){</p>
<p>​      console.timeEnd(‘main’)</p>
<p>​      cluster.disconnect()</p>
<p>​    }</p>
<p>  })</p>
<p>} else {</p>
<p>  process.on(‘message’, item =&gt; { //子进程通信</p>
<p>​    fibonacci(item)</p>
<p>​    process.send(‘ok’)</p>
<p>  })</p>
<p>}</p>
<p>上述代码中，我们使用node的cluster模块开启4个子进程，每个子进程中使用单线程处理数组中的一个元素的斐波那契运算，总共运算时间为5.871s左右。相当于之前正常运行情况的四分之一。</p>
<h2 id="http-1-0和http-2-0"><a href="#http-1-0和http-2-0" class="headerlink" title="http 1.0和http 2.0"></a>http 1.0和http 2.0</h2><h3 id="http-1-0和http1-1的区别"><a href="#http-1-0和http1-1的区别" class="headerlink" title="http 1.0和http1.1的区别"></a>http 1.0和http1.1的区别</h3><p>http 1.0主要解决早期前端中服务器和浏览器发送文本的需求，随着前端的不断发展，出现了http 1.1，在http 1.0的基础上，提出了缓存和长连接等概念，解决了前端中网络优化的部分问题。</p>
<h3 id="http、https的区别"><a href="#http、https的区别" class="headerlink" title="http、https的区别"></a>http、https的区别</h3><p>Plain  Text</p>
<p>1.HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>2.HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p>
<p>3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4.HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>Plain  Text</p>
<p>第一次握手：浏览器向原服务器请求建立连接，主机A告诉主机B我要和你通信 不是dns服务器，</p>
<p>第二次握手：主机B收到主机A的请求后，告诉主机A我已经收到你的请求了，你可以传输数据了</p>
<p>第三次握手：主机A收到确认收到主机B返回信息，告诉B我已收到回复，现在可以传输数据</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>Plain  Text</p>
<p>第一次挥手：当主机A完成数据传输后,向主机B提出停止TCP连接的请求 ；</p>
<p>第二次挥手：主机B收到后对其作出响应，确认这一方向上的TCP连接将关闭</p>
<p>第三次挥手：主机B发送关闭请求</p>
<p>第四次挥手：主机A对主机B的请求进行确认，双方向的关闭结束.。</p>
<h2 id="event事件模块"><a href="#event事件模块" class="headerlink" title="event事件模块"></a>event事件模块</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>events模块给我们提供了自定义事件和执行自定义事件的方法，如下代码：</p>
<p>JavaScript</p>
<p>var EventEmitter = require(‘events’).EventEmitter;</p>
<p>var a = new EventEmitter();</p>
<p>a.addListener(‘handle’ ,function(){</p>
<p>  console.log(‘handle事件执行了’)</p>
<p>})</p>
<p>a.emit(‘handle’)</p>
<h3 id="events模块与发布订阅者模式的关系"><a href="#events模块与发布订阅者模式的关系" class="headerlink" title="events模块与发布订阅者模式的关系"></a>events模块与发布订阅者模式的关系</h3><p>Node.js 中的 EventEmitter模块就是用了发布/订阅这种设计模式，发布/订阅模式在主体与观察者之间引入消息调度中心，主体和观察者之间完全透明，所有的消息传递过程都通过消息调度中心完成，也就是说具体的业务逻辑代码将会是在消息调度中心内完成。</p>
<p>在上述代码中，EventEmitter就是一个调度中心，我们可以使用addListener订阅事件，并且用过emit发布事件，具体可以参照发布订阅模式了解。</p>
<h2 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h2><h3 id="请求报文request"><a href="#请求报文request" class="headerlink" title="请求报文request"></a>请求报文request</h3><p>一个HTTP请求报文由请求行、请求头部、空行、请求数据4部分组成，下图是请求报文的格式：</p>
<p><img src="https://uploader.shimo.im/f/vagiWlDWJRfhah9z.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/vagiWlDWJRfhah9z.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>具体这四部分包含的内容如下：</p>
<p>Plain  Text</p>
<p>请求行：由请求方法，URL字段和HTTP协议版本组成</p>
<p>请求头部：由关键字键值对组成，如Cache-Control：max-age=2000</p>
<p>空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<p>请求数据：不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h3 id="响应报文response"><a href="#响应报文response" class="headerlink" title="响应报文response"></a>响应报文response</h3><p>响应报文由状态行、响应报头、响应正文组成，这三部分具体内容如下：</p>
<p>Plain  Text</p>
<p>状态行：HTTP协议版本 状态码 状态码描述，如HTTP1.0 200 OK</p>
<p>响应报头：由关键字键值对组成，如Content-Type：text/plain;charset=utf-8</p>
<p>响应正文：响应的html文件</p>
<h2 id="DNS域名系统，简单描述其工作原理"><a href="#DNS域名系统，简单描述其工作原理" class="headerlink" title="DNS域名系统，简单描述其工作原理"></a>DNS域名系统，简单描述其工作原理</h2><p>DNS（domain name system）域名系统或者（domain named system）区域名称服务，分为正向与反向域名解析，属于应用层协议。</p>
<p>作用：人的记忆有限，如果没有dns得记下很多IP地址。从网络来说由于tcp/ip协议是基于ip地址，所以需要一个翻译器即DNS。可以1对多也可以多对1，正向解析即域名解析为ip地址，反向解析即ip地址解析为域名。你可以将DNS比作一个大的电话本。</p>
<h2 id="如何避免多个js脚本发生冲突？"><a href="#如何避免多个js脚本发生冲突？" class="headerlink" title="如何避免多个js脚本发生冲突？"></a>如何避免多个js脚本发生冲突？</h2><p>当一个项目涉及到多人开发的时候，每个人写的js文件中很难说自己的变量不和别人的变量重复，如果不同的js中设置了变量名相同的变量，此时再将他们引入到html文件中，就会发生变量的覆盖即js文件冲突。为了解决这个问题，你可以使用闭包的方式，如下代码：</p>
<p>JavaScript</p>
<p>//1.js</p>
<p>function Url(){</p>
<p>  var parse = function(){</p>
<p>   console.log(‘url.parse’)</p>
<p>  }</p>
<p>  var stringfiy = function(){</p>
<p>   console.log(‘url.stringfiy’)</p>
<p>  }</p>
<p>  return {</p>
<p>   parse,</p>
<p>   stringfiy</p>
<p>  }</p>
<p>}</p>
<p>var url = Url();</p>
<p>JavaScript</p>
<p>//2.js</p>
<p>function Path(){</p>
<p> var parse = function(){</p>
<p>  console.log(‘path.parse’)</p>
<p> }</p>
<p> var stringfiy = function(){</p>
<p>  console.log(‘path.stringfiy’)</p>
<p> }</p>
<p> return {</p>
<p>  parse,</p>
<p>  stringfiy</p>
<p> }</p>
<p>}</p>
<p>var path = Path();</p>
<p>将上述两个js文件引入到html中，并且访问相同的parse方法</p>
<p>HTML, XML</p>
<!DOCTYPE html>

<html lang="en">

<head>

<p>    <meta charset="UTF-8"></p>
<p>    <meta http-equiv="X-UA-Compatible" content="IE=edge"></p>
<p>    <meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
  <title>Document</title>

</head>

<body>

<p>    <script src="./1.js"></script></p>
<p>    <script src="./2.js"></script></p>
<p>    <script></p>
<p>​    path.parse()</p>
<p>​    url.parse()</p>
<p>  </script></p>
</body>

</html>

<p>如上述代码，两个parse方法不会发生冲突，上述的1.js和2.js可以理解为不同的人开发的不同模块，虽然都有parse方法，但是不互相影响。</p>
<h1 id="React单元"><a href="#React单元" class="headerlink" title="React单元"></a>React单元</h1><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><h3 id="为什么使用setState？"><a href="#为什么使用setState？" class="headerlink" title="为什么使用setState？"></a>为什么使用setState？</h3><p>在react中，使用同步更改state之后，react本身并不能感知state已经发生变化，必须使用setState来告诉react state的变化情况。举例如下：</p>
<p>JavaScript</p>
<p>class App extends React.Component{</p>
<p> constructor(){</p>
<p>  super()</p>
<p>  this.state = {</p>
<p>   count : 0</p>
<p>  }</p>
<p> }</p>
<p> change(){</p>
<p>  this.state.count+=1;</p>
<p>  console.log(this.state.count);</p>
<p>​    //随着change的执行count会变化，但是页面不会更新</p>
<p> }</p>
<p> render(){</p>
<p>  return(</p>
<p>      <div></p>
<p>         <div>{this.state.count}</div></p>
<p>​     &lt;button onClick={()=&gt;{this.change()}}&gt;点击更改state</button></p>
   </div>

<p>  )</p>
<p> }</p>
<p>}</p>
<h3 id="setState如何更新state？"><a href="#setState如何更新state？" class="headerlink" title="setState如何更新state？"></a>setState如何更新state？</h3><p>JavaScript</p>
<p>class App extends React.Component{</p>
<p> constructor(){</p>
<p>  super()</p>
<p>  this.state = {</p>
<p>   count : 0</p>
<p>  }</p>
<p> }</p>
<p> change(){</p>
<p>  this.setState({</p>
<p>   count : this.state.count+1</p>
<p>  })</p>
<p>  console.log(this.state.count);</p>
<p> }</p>
<p> render(){</p>
<p>  return(</p>
<p>      <div></p>
<p>         <div>{this.state.count}</div></p>
<p>​     &lt;button onClick={()=&gt;{this.change()}}&gt;点击更改state</button></p>
   </div>

<p>  )</p>
<p> }</p>
<p>}</p>
<p>运行上述代码，可以发现当执行完setState之后，打印的count还是上一次的值，说明setState异步更新了state。</p>
<h3 id="为什么要将setState设计成异步的呢？"><a href="#为什么要将setState设计成异步的呢？" class="headerlink" title="为什么要将setState设计成异步的呢？"></a>为什么要将setState设计成异步的呢？</h3><p>因为如果state更新是同步的，也就意味着每一次更改state都要重新render，那么如果同一时间有多个state被更改，render函数也将执行多次，浪费了性能，最好的方式是获取到多个state更新，将他们放到同一个队列中，统一处理。</p>
<h3 id="如何获取异步更新之后的state"><a href="#如何获取异步更新之后的state" class="headerlink" title="如何获取异步更新之后的state"></a>如何获取异步更新之后的state</h3><p>在上述代码中可以看到，调用setState之后直接打印当前的state是不能获取最新的state的，为了解决这个问题，你可以给setState设置第二个参数，代码如下：</p>
<p>JavaScript</p>
<p>class App extends React.Component{</p>
<p> constructor(){</p>
<p>  super()</p>
<p>  this.state = {</p>
<p>   count : 0</p>
<p>  }</p>
<p> }</p>
<p> change(){</p>
<p>  this.setState({</p>
<p>   count : this.state.count+1</p>
<p>  },()=&gt;{</p>
<p>   console.log(this.state.count);</p>
<p>  })</p>
<p> }</p>
<p> render(){</p>
<p>  return(</p>
<p>      <div></p>
<p>         <div>{this.state.count}</div></p>
<p>​     &lt;button onClick={()=&gt;{this.change()}}&gt;点击更改state</button></p>
   </div>

<p>  )</p>
<p> }</p>
<p>}</p>
<h3 id="setState什么情况下会同步更新state"><a href="#setState什么情况下会同步更新state" class="headerlink" title="setState什么情况下会同步更新state"></a>setState什么情况下会同步更新state</h3><p>原则上setState会异步更新state，但在某种情况下是可以实现同步更新的：</p>
<p>JavaScript</p>
<p>class App extends React.Component {</p>
<p> constructor() {</p>
<p>  super()</p>
<p>  this.state = {</p>
<p>   count: 0</p>
<p>  }</p>
<p> }</p>
<p> change() {</p>
<p>  setTimeout(() =&gt; {</p>
<p>   this.setState({</p>
<p>​    count: this.state.count + 1</p>
<p>   })</p>
<p>   console.log(this.state.count)</p>
<p>  }, 0)</p>
<p> }</p>
<p> render() {</p>
<p>  return (</p>
<p>      <div></p>
<p>        <div>{this.state.count}</div></p>
<p>​    &lt;button onClick={() =&gt; { this.change() }}&gt;点击更改state</button></p>
   </div>

<p>  )</p>
<p> }</p>
<p>}</p>
<p>上述代码中，将setState函数放在延时器中，即可实现同步更新。其他情况下为异步更新。</p>
<h2 id="react更新机制"><a href="#react更新机制" class="headerlink" title="react更新机制"></a>react更新机制</h2><p>在react中，props或state的变化会引起重新render，重新render会创建一个新的虚拟dom树，react将新的虚拟dom树和之前的虚拟dom树进行对比来判断应该更新的元素。比较的原理就是相同节点进行比较，不会跨节点比较。不同类型的节点产生不同的树结构。可以根据key来指定节点的渲染。</p>
<p>当对比发现节点元素变化了，则会将之前这个节点的树结构ll，生成新的节点树结构：</p>
<p>Plain  Text</p>
<p>div变为span这种情况，会将div所在的树拆解，生成新的span树</p>
<p>树被卸载执行componentWillUnmount生命周期</p>
<p>树被新建执行componentWillMount和componentDidMount生命周期</p>
<p>当对比发现节点元素没变，属性发生变化了，则会通过对比两个元素，修改指定的属性：</p>
<p>Plain  Text</p>
<p>div的color发生变化，调用componentReceivePorps和componentWillUpdate方法</p>
<h2 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h2><p>在写动态子组件的时候，我们经常会看到警告说要给每一个li设置key属性，因为通过遍历生成的li节点在发生更新的时候，可以使用key进行优化。key用来标识当前的子元素，如果子元素没有发生变化只是位置改变了，则可以使用key来移动子组件的位置，而不需要重新创建。比如下面这种例子：</p>
<p>HTML, XML</p>
<p>​    <ul></p>
<p>​     <li>1</li></p>
<p>​     <li>2</li></p>
<p>​    </ul></p>
<p>当我们需要对一个数组[1,2]进行动态渲染时，给每一个li一个key属性，如果数组在下一刻变成了[1,3,2,4]，我们就可以根据给之前li设置的key来移动之前的li，然后将新添加的li添加到相应的位置。</p>
<p>那么key如何设置呢？很多用户在设置key的时候没有注意到key的唯一性原则，所以当你通过map方法遍历生成子元素的时候，不要将index赋值给key，因为当数组发生变化的时候，index并不可靠。你可以选择给每一个要渲染的元素设置唯一的id，把这个id作为key的值，或者当你从服务器获取到数据库中的数据之后，每一个数据拥有其在数据库中的唯一id，把这个id作为key的值也是可以的。</p>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="hooks中的生命周期"><a href="#hooks中的生命周期" class="headerlink" title="hooks中的生命周期"></a>hooks中的生命周期</h3><p>在hooks中，我们使用useEffect代替原本的class组件的生命周期，代码如下：</p>
<p>Plain  Text</p>
<p>import {useState , useEffect} from ‘react’</p>
<p>function Per(){</p>
<p> var [a , setA] = useState(0);</p>
<p> var updateChange = function(){</p>
<p>  setA(++a)</p>
<p> }</p>
<p> useEffect(()=&gt;{</p>
<p>  console.log(‘组件被装载了’)</p>
<p>  return function(){</p>
<p>   console.log(‘组件被卸载了’)</p>
<p>  }</p>
<p> },[a])</p>
<p> return(</p>
<p>    <div></p>
<p>      <p>{a}</p></p>
<p>   <button onClick = {updateChange}>点击</button></p>
  </div>

<p> )</p>
<p>}</p>
<p>function App(){</p>
<p> var [now,setNow] = useState(true);</p>
<p> return(</p>
<p>    <div></p>
<p>   {now ? <Per></Per> : “”}</p>
<p>   &lt;button onClick={()=&gt;{setNow(!now)}}&gt;改变now</button></p>
  </div>

<p> )</p>
<p>}</p>
<p>上述代码中，将Per组件引入到App组件中，使用useState初始化两个组件的状态，在Pre组件中，用useEffect传入的第一个参数，作为componentDidMount生命周期，每次组件被装载都会执行，第二个参数传递一个依赖项，只要依赖项的值发生变化，也会调用useEffect的第一个参数，即用这种传递依赖项的方式，作为componentUpdate生命周期，在useEffect中用return返回一个函数，这个函数就是当组件写在的时候会执行，此时你可以点击App中的button来卸载Per组件，可以观察控制台预览效果。</p>
<h2 id="react中的diff算法"><a href="#react中的diff算法" class="headerlink" title="react中的diff算法"></a>react中的diff算法</h2><h3 id="传统的diff算法"><a href="#传统的diff算法" class="headerlink" title="传统的diff算法"></a>传统的diff算法</h3><p>传统的diff算法通过递归对旧树和新树的节点依次进行对比，效率低下，算法复杂度达到O(n^3)，这意味着要展示n个节点，需要执行n^3的比较，即时你的cpu每秒可以执行30亿次操作，也很难在一秒内计算出差异情况。</p>
<p>因此，react要想使用diff算法，就必须在传统的基础上对其进行优化。</p>
<h3 id="react中的diff"><a href="#react中的diff" class="headerlink" title="react中的diff"></a>react中的diff</h3><p>react将虚拟dom转换成真实dom的最少操作称之为调和，react diff算法就是调和的具体实现。</p>
<p>react diff遵循三个策略：</p>
<ol>
<li><p>dom跨层级移动操作特别少，可以忽略不计</p>
</li>
<li><p>拥有相同类的两个组件会生成相似的树形结构，拥有不同类的两个组件会生成不同的树形结构。</p>
</li>
<li><p>对于同一级的一组子节点，他们可以通过唯一的id进行区分。</p>
</li>
</ol>
<p>基于以上三个策略，react分别对tree diff、component diff、element diff进行算法优化。</p>
<p><strong>tree diff</strong></p>
<p>基于策略1，react对树进行分层比较，两棵树只会对同一层次的节点进行比较，不会跨节点比较。react通过updateDepth方法对虚拟dom树进行层级控制，只会对相同层级的dom节点进行比较，即同一个父节点下的所有子节点。如果发现节点不存在时，则该节点即其子节点全部删除，不会进一步比较。这样只需要对树进行一次遍历，便能完成对整个dom树的比较。</p>
<p>那如果用户非要跨层级进行移动操作呢，diff会怎么做呢？如下图：</p>
<p><img src="https://uploader.shimo.im/f/IufL03XJnW2V0xfS.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/IufL03XJnW2V0xfS.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>当左边的树变为右边的树的时候，有些用户想通过直接移动来完成操作，但是react diff不允许我们这么做，它会在右边树的D节点下边创建A节点，依次创建B C节点，然后删除左边树的A节点，并且连带B C节点也会删除。流程为：创建A=&gt;创建B=&gt;创建C=&gt;删除A。</p>
<p><strong>component diff</strong></p>
<p>react对于组件间的比较有以下规则：</p>
<ol>
<li><p>如果是同一类型的组件，按照原策略比较虚拟dom即可</p>
</li>
<li><p>如果不是，则将原组件判断为脏组件，并替换整个组件下的所有子节点。</p>
</li>
<li><p>对于同一类型的组件，可能其虚拟dom没有发生任何变化，如果能知道确切的变化，则可以省下大量的diff时间。因此，用户可以通过shouldComponentUpdate()来判断组件是否需要进行diff运算。</p>
</li>
</ol>
<p>如下图：</p>
<p><img src="https://uploader.shimo.im/f/vlDTtK6m7J1f3OG4.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/vlDTtK6m7J1f3OG4.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>当树中的D组件变为G组件的时候，即使两个组件结构相似，但是react判断D和G是不同的组件，则会直接删除D组件，重新创建一个相同结构的G组件。虽然D组件和G组件结构相似，你会觉得直接删除再创建会消耗性能，但正如react官方所言，不同类型的组件很少有相同结构的情况，如果有，那可能是你不懂得封装组件。</p>
<p><strong>element diff</strong></p>
<p>当处于统一层级的节点进行比较时，react允许我们可以对这些节点进行删除，插入和移动操作。</p>
<p>插入：新的组件不在旧的集合中，即全新的节点，则对新结点进行插入操作</p>
<p>移动：旧的集合中有新的组件类型，且element是可以更新的类型，这种情况下只需要对节点进行移动。</p>
<p>删除：部分组件类型在新的集合中有，在旧的集合中也有，但是element不同，即不能复用，就需要执行删除操作，或者旧集合中的某组件不再新的集合中，也需要进行删除操作。</p>
<p>如下图：</p>
<p><img src="https://uploader.shimo.im/f/8wD1XFe4QnPGkYDy.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/8wD1XFe4QnPGkYDy.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>react diff在对比新旧集合的时候，会做以下操作：</p>
<ol>
<li><p>从新集合中取出B，判断旧集合中存在B，接着通过对比节点位置判断是否需要移动。取出旧集合中B的位置mountIndex为1，取出新集合中B的位置lastIndex=0，此时只需要判断mountIndex&lt;lastIndex条件如果成立，则进行移动，如果不成立，则不移动。所以B节点不进行移动，更新lastIndex = Math.max(mountIndex,lastIndex)，即lastIndex变为1，并将B的mountIndex更新为mountIndex=nextIndex，此时B在新集合中的nextIndex=0，即mountIndex更新为0。nextIndex++，进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取出A，判断旧集合中存在A，取出旧集合中A的位置mountIndex=0，取出新集合中A的位置lastIndex=1，满足mountIndex&lt;lastIndex，所以移动A。</p>
</li>
<li><p>同理，不移动D</p>
</li>
<li><p>同理，移动C</p>
</li>
</ol>
<p>上边主要分析了新旧集合中存在的相同节点但是位置不同时的情况，对于新集合中有新节点的插入和就集合中存在需要删除的节点情况，请看下图：</p>
<p><img src="https://uploader.shimo.im/f/SqOsg2IcExN24WUp.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/SqOsg2IcExN24WUp.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<ol>
<li><p>从新集合中取出B，判断旧集合中存在B，取出旧集合中B的mountIndex=1，取出新集合中B的lastIndex=0，不符合mountIndex&lt;lastIndex，所以不移动B，更新lastIndex=1，mountIndex=0。nextIndex++，进入下一个节点判断。</p>
</li>
<li><p>从新集合中取出E，判断旧集合中不存在E，此时创建新节点E，更新lastIndex=1，并将E的位置更新为新集合中的位置，nextIndex++，进入下一个节点判断</p>
</li>
<li><p>从新集合中取出C，判断旧集合中存在C，C的mountIndex=2，C的lastIndex=1,不符合lastIndex&lt;mountIndex，所以不移动C，更新lastIndex=2，并将C的位置更新为新集合中的位置，nextIndex++，进入下一个节点判断</p>
</li>
<li><p>同理，移动A</p>
</li>
<li><p>当完成新集合中的差异化后，还需要对旧集合循环遍历，此时发现旧集合中存在D，因此删除D，到此diff算法完成。</p>
</li>
</ol>
<h1 id="Vue单元"><a href="#Vue单元" class="headerlink" title="Vue单元"></a>Vue单元</h1><h2 id="vue中axios如何设置拦截器？"><a href="#vue中axios如何设置拦截器？" class="headerlink" title="vue中axios如何设置拦截器？"></a>vue中axios如何设置拦截器？</h2><p>首先我们先看一下axios的简单使用方式，代码如下：</p>
<p>JavaScript</p>
<p>//get请求</p>
<p> axios</p>
<p>   .get(“/demo1?id=123”)</p>
<p>   .then((data) =&gt; {</p>
<p>​    console.log(data);</p>
<p>   })</p>
<p>   .catch((error) =&gt; {</p>
<p>​    console.log(error);</p>
<p>   });</p>
<p>上述的get请求也可以更改为：</p>
<p>JavaScript</p>
<p>axios</p>
<p>   .get(‘/demo’ , {</p>
<p>​     params:{</p>
<p>​      id:123</p>
<p>​     }</p>
<p>   })</p>
<p>   .then((data) =&gt; {</p>
<p>​    console.log(data);</p>
<p>   })</p>
<p>   .catch((error) =&gt; {</p>
<p>​    console.log(error);</p>
<p>   });</p>
<p>下面是post请求：</p>
<p>JavaScript</p>
<p> axios.post(‘/demo1’ , {</p>
<p>   token : “1212312”</p>
<p>  }).then((val)=&gt;{</p>
<p>   cosnole.log(val)</p>
<p>  }).catch((error)=&gt;{</p>
<p>   console.log(error)</p>
<p>  })</p>
<p>如果我们发送的请求都需要携带token等字段进行鉴权验证的话，可以封装一个请求过滤器(拦截器)，当收到不同的响应码时进行相应的处理，代码如下：</p>
<p>JavaScript</p>
<p>//request.js</p>
<p>import axios from ‘axios’;</p>
<p>const service = axios.create({})</p>
<p>service.interceptors.request.use((config)=&gt;{</p>
<p>  console.log(‘请求之前可以做点什么’)</p>
<p>req.header.cookie = loalstrong.token</p>
<p>  if(localStorage.token){</p>
<p>//通过cookie</p>
<p>//</p>
<p>​    return config </p>
<p>  }</p>
<p>  else{</p>
<p>​    return Promise.reject(“请求缺少token”)</p>
<p>  }</p>
<p>})</p>
<p>service.interceptors.response.use((response)=&gt;{</p>
<p>  console.log(‘响应收到后做点什么’);</p>
<p>  if(response.status == 200){</p>
<p>​    return response</p>
<p>  }else{</p>
<p>​    return Promise.reject(‘响应失败’)</p>
<p>  }</p>
<p>})</p>
<p>export default service;</p>
<p>你可以在vue项目的src文件夹中新建一个request.js来设置拦截器，拦截器代码如上。首先使用axios.create创建一个请求，设置service.interceptors.request.use即请求拦截器，在请求之前你可以做你想做的，比如验证token是否存在，如果存在返回config参数(正常执行)，否则返回错误。同时也可以设置service.interceptors.response.use响应拦截器，在响应收到后你可以做你想做的，比如判断响应状态码是否为200。</p>
<h2 id="vue更新机制"><a href="#vue更新机制" class="headerlink" title="vue更新机制"></a>vue更新机制</h2><p>在vue中，我们对每一个state设置了getter和setter，这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<p><img src="https://uploader.shimo.im/f/Zh8rVy2aLJedTuMr.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/Zh8rVy2aLJedTuMr.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ece23bbc1dc9">https://www.jianshu.com/p/ece23bbc1dc9</a></p>
<h1 id="Webpack单元"><a href="#Webpack单元" class="headerlink" title="Webpack单元"></a>Webpack单元</h1><h2 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h2><h2 id="Loader和Plugin是做什么的？"><a href="#Loader和Plugin是做什么的？" class="headerlink" title="Loader和Plugin是做什么的？"></a>Loader和Plugin是做什么的？</h2><h2 id="常见的loader有哪些-？解决了什么问题？"><a href="#常见的loader有哪些-？解决了什么问题？" class="headerlink" title="常见的loader有哪些 ？解决了什么问题？"></a>常见的loader有哪些 ？解决了什么问题？</h2><h2 id="常见的Plugin有哪些？解决了什么问题？"><a href="#常见的Plugin有哪些？解决了什么问题？" class="headerlink" title="常见的Plugin有哪些？解决了什么问题？"></a>常见的Plugin有哪些？解决了什么问题？</h2><h2 id="webpack热更新原理是什么？"><a href="#webpack热更新原理是什么？" class="headerlink" title="webpack热更新原理是什么？"></a>webpack热更新原理是什么？</h2><h2 id="webpack构建项目的流程？"><a href="#webpack构建项目的流程？" class="headerlink" title="webpack构建项目的流程？"></a>webpack构建项目的流程？</h2><h1 id="浏览器单元"><a href="#浏览器单元" class="headerlink" title="浏览器单元"></a>浏览器单元</h1><h2 id="为什么要进行前端优化？"><a href="#为什么要进行前端优化？" class="headerlink" title="为什么要进行前端优化？"></a>为什么要进行前端优化？</h2><p>在说明这个问题之前，我们先要了解一下前端的架构模式。</p>
<p>当今软件架构方式主要为C/S架构和B/S架构。</p>
<p><img src="https://uploader.shimo.im/f/uQZhvbKoNVVgKawb.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/uQZhvbKoNVVgKawb.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>上图为一个C/S架构的大体流程图，程序员编写好代码，并且将代码打包成为一个apk文件，发布到手机的应用商店里边，用户可以通过应用商店下载并且安装这个apk文件，当apk文件在手机端运行的时候，其实所有的逻辑在手机本地是有一份的，所以对于这种架构模式来说，请求和执行速度很快。并且对于部分资源，手机本地内存中也是有一份的，所以请求起来耗时很少。</p>
<p><img src="https://uploader.shimo.im/f/5l9j7dgDGrRdk3vN.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/5l9j7dgDGrRdk3vN.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>而对于一个B/S架构来说，程序员写好代码，将代码发布到远程服务器，用户可以通过浏览器去访问这个远程服务器，获取相应的资源。那么对于这种架构来说，用户访问一个网站的时间就需要根据当前的网速，下载的资源的大小等等一些因素去决定。所以为了提高用户的体验，必须在用户与服务器之间进行一定的优化。前端就是属于B/S架构模式，所以前端优化是必须要做的。</p>
<h2 id="一个URl从发送到返回都经历了什么？"><a href="#一个URl从发送到返回都经历了什么？" class="headerlink" title="一个URl从发送到返回都经历了什么？"></a>一个URl从发送到返回都经历了什么？</h2><p><img src="https://uploader.shimo.im/f/mQXpEvRwHVUgMxJx.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/mQXpEvRwHVUgMxJx.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>上图为一个请求和响应的流程图，当一个url输入浏览器发起请求到获取响应，他具体会经历以下几个过程：</p>
<p>Plain  Text</p>
<p>1.用户输入url，浏览器会将输入的url进行解析，并且将一个domain发送到DNS服务器上。</p>
<p>2.DNS服务器根据domain查询相应的ip地址，并且将ip地址发回给浏览器</p>
<p>3.浏览器根据获取的ip地址，发起请求</p>
<p>4.请求经过路由器，主干网络到达服务器</p>
<p>5.服务器如果是一个MVC架构，请求会先到逻辑层，在逻辑层进行请求的分发和处理，然后调用数据层，数据层可以访问数据库进行增删查改操作，并且将最终的渲染效果通过视图层返回响应</p>
<p>6.响应通过主干网络路由器返回给浏览器</p>
<p>7.浏览器根据响应的html，css形成dom树和css dom树，并将dom树和css dom树整合形成render树。最终将render树渲染到页面中。</p>
<p>8.浏览器根据响应的js执行脚本。</p>
<p>9.完整页面展示</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="前端可以做哪些方面的优化？"><a href="#前端可以做哪些方面的优化？" class="headerlink" title="前端可以做哪些方面的优化？"></a>前端可以做哪些方面的优化？</h2><p><img src="https://uploader.shimo.im/f/mQXpEvRwHVUgMxJx.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/mQXpEvRwHVUgMxJx.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>根据上图，我们需要整理平且判断前端可以在哪些方面进行优化，这些优化包含了如下几点：</p>
<p>Plain  Text</p>
<p>1.DNS服务器优化，可以在这个层面进行前端缓存，减少DNS查询时间</p>
<p>2.网络请求层面，可以将一些静态资源在浏览器缓存，减少请求资源次数</p>
<p>3.减小http请求资源的大小，使页面加载速度更快</p>
<p>4.将多次http请求合并为一次，减少http请求的次数</p>
<p>5.将vue框架的一部分在服务端进行渲染 </p>
<h2 id="HTML页面加载渲染过程"><a href="#HTML页面加载渲染过程" class="headerlink" title="HTML页面加载渲染过程"></a>HTML页面加载渲染过程</h2><p><img src="https://uploader.shimo.im/f/S7jhoiAq1x0tZLb0.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/S7jhoiAq1x0tZLb0.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>输入url请求一个网站，我们会最得到一个html文件的响应，然后浏览器根据词法分析分析出html文件中所有的节点信息，将这些节点信息添加到dom树中。在生成dom树的这个过程中会加载出link以及script标签，根据这些标签所引入的外部资源，浏览器会并发的去服务器拿取这些文件。当css文件请求到之后也会经过词法解析，生成相应的css dom树。只有当dom树和css dom树都构建完成后，就会生成render树，进而将render树中的元素通过页面布局和上色渲染出来让用户看到。script引入的js文件也会相应的加载出来并且交给chrome v8引擎去进行解析。</p>
<h2 id="cookie、localStroage、sessionStorage的作用和区别"><a href="#cookie、localStroage、sessionStorage的作用和区别" class="headerlink" title="cookie、localStroage、sessionStorage的作用和区别"></a>cookie、localStroage、sessionStorage的作用和区别</h2><p>作用：</p>
<p>Plain  Text</p>
<p>cookie：为了标识用户身份而存储的数据，会在http请求中携带，大小4kb左右</p>
<p>localstroage：浏览器存储，大小5m</p>
<p>sessionStroage：浏览器存储，大小5m</p>
<p>区别：</p>
<p>Plain  Text</p>
<p>cookie：可以设置过期时间 跨域不能获取，但可以设置</p>
<p>localStroage：持久化存储数据，不手动清除则一直存在</p>
<p>sessionStroage：当前窗口关闭，则消失</p>
<p>操作：</p>
<p>Plain  Text</p>
<p>localStroage：localStroage.setItem(‘a’ , ‘111’)</p>
<p>sessionStroage：sessionStroage.setItem(‘a’ , ‘111’)</p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>内核主要分为两个部分：渲染引擎、js引擎</p>
<p>渲染引擎：负责取得网页的内容（html css img …），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核不同对于网页的语法解释也不同，所以渲染的效果也不一样</p>
<p>js引擎：解析和执行javascript 来实现网页的动态效果。最开始渲染引擎和js引擎并没有区分的很明确，后来js引擎越来越独立，内核就倾向于js引擎。</p>
<p>不同浏览器内核如下：</p>
<p>Plain  Text</p>
<p>IE:trident</p>
<p>Firefox：gecko</p>
<p>Safari: webkit</p>
<p>Opera :Blink</p>
<p>Chrome:Blink</p>
<h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>Plain  Text</p>
<p> get：获取数据</p>
<p> post:提交数据</p>
<p> put:更新数据</p>
<p> head:请求页面的首部信息</p>
<p> delete:删除服务器上的资源</p>
<p> options:用于获取当前URL支持的请求方式,预检请求</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>Plain  Text</p>
<p>1** ： 100（continue）,代表继续</p>
<p>2** : 200代表成功，201代表请求成功且服务器创建了新资源，202，服务器接收请求但尚未处理</p>
<p>3** ： 301重定向，302临时重定向，304协商缓存</p>
<p>4** ： 401请求未授权，403禁止访问，404资源未找到</p>
<p>5** ： 500服务器错误</p>
<h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 </p>
<ol>
<li><p>对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 “-“ 进行转换等</p>
</li>
<li><p>永远不要使用动态拼装SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取</p>
</li>
<li><p>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</p>
</li>
<li><p>不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息</p>
</li>
</ol>
<h3 id="xss防范"><a href="#xss防范" class="headerlink" title="xss防范"></a>xss防范</h3><p>指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 </p>
<p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对 &lt;，&gt;，; 等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</p>
<h3 id="xss与csrf区别"><a href="#xss与csrf区别" class="headerlink" title="xss与csrf区别"></a>xss与csrf区别</h3><p>XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。 CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次 CSRF 攻击，受害者必须依次完成两个步骤，</p>
<ol>
<li><p>登录受信任网站 A ，并在本地生成 Cookie 。</p>
</li>
<li><p>在不登出 A 的情况下，访问危险网站 B </p>
</li>
</ol>
<h2 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h2><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<h2 id="长轮询短轮询"><a href="#长轮询短轮询" class="headerlink" title="长轮询短轮询"></a>长轮询短轮询</h2><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>每隔几秒就向服务器发起请求，服务器接收到请求立刻发出响应</p>
<p>Plain  Text</p>
<p>优点：兼容性好，使用http即可完成</p>
<p>缺点：过多消耗资源</p>
<p>实现方式如下：</p>
<p>JavaScript</p>
<p>function Ajax() {</p>
<p>  axios.get(url).then(data =&gt; {</p>
<p>​    //do some </p>
<p>  }).catch(err =&gt; {</p>
<p>​    console.log(err);</p>
<p>  });</p>
<p>}</p>
<p>setInterval(Ajax, 10000);</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。</p>
<p>实现方式：</p>
<p>JavaScript</p>
<p>function Ajax() {</p>
<p>  axios.get(url).then(data =&gt; {</p>
<p>​    //do some </p>
<p>  }).catch(err =&gt; {</p>
<p>​    console.log(err);</p>
<p>  });</p>
<p>}</p>
<p>Ajax()</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是大家经常听到的一个名词，它可以帮助我们在前端优化方面做出调整。在生活中大家可以看到如果A同学和B同学沟通起来比较高效，能在很短的时间内完成很多的工作，而A同学和C同学沟通起来就比较低效，需要A做出很多的反馈给C，让整个工作变得缓慢。这其实决定于沟通双方之间是否建立了高效的沟通策略，如果沟通对象一个抛眼神给你，你就能明白你要做什么事，而不是需要对方长篇大论的解释，就说明你们之间已经建立了高效的沟通策略。</p>
<p>在浏览器和服务器沟通的过程中，他们有没有建立这种高效的沟通策略呢？其实在很久之前这种高效的策略就被应用到我们的页面中了，他就是缓存，下面我们来看一个例子：</p>
<p><img src="https://uploader.shimo.im/f/l60GnRhdxdgElB0e.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/l60GnRhdxdgElB0e.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>这是牛客网的Network栏一部分资源加载的情况，其中一些资源状态码为200，是从memory cache(浏览器缓存)中读取的，读取时间为0ms。一些资源的状态码为304，是从服务器加载的，加载大小为168b，加载时间为10ms，还有一些资源状态码为200，是从disk cache中读取的，读取时间为2ms。那么是什么导致了资源读取的不同呢？原因就是服务器和浏览器之间已经建立了缓存策略，不同的缓存策略会导致资源读取位置的不同，本节我们就来学习一下。</p>
<h3 id="Cache-Control缓存策略"><a href="#Cache-Control缓存策略" class="headerlink" title="Cache-Control缓存策略"></a><strong>Cache-Control缓存策略</strong></h3><p>在浏览器和服务器建立连接的时候，他们之间需要借助httpHeader来进行缓存策略的实现，即request.header和response.header。</p>
<p>在设置的httpHeader中我们比较常用的就是Cache-Control所控制的缓存策略，它借助一些属性能实现不同情况的资源请求。Cache-Control可以携带在request.header请求头和response.header响应头中，他的作用就是让浏览器和服务器相互知道对方的缓存情况。下面是这些属性的具体意义。</p>
<table>
<thead>
<tr>
<th>Cache-Control</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>max-age</td>
<td>缓存最大有效时间 (private)</td>
</tr>
<tr>
<td>s-maxage</td>
<td>缓存最大有效时间 (public)</td>
</tr>
<tr>
<td>private</td>
<td>私有缓存设备(个人PC)</td>
</tr>
<tr>
<td>public</td>
<td>公共缓存设备(CND代理服务器)</td>
</tr>
<tr>
<td>no-cache</td>
<td>不管缓存有没有过期，使用资源前，一定要到服务器确认资源有效性</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>资源过期前，使用缓存资源，过期后，一定要到服务器确认资源有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>完全不缓存</td>
</tr>
</tbody></table>
<h4 id="max-age强制缓存"><a href="#max-age强制缓存" class="headerlink" title="max-age强制缓存"></a>max-age强制缓存</h4><p>当浏览器收到一个资源的响应头，响应头中携带了max-age且max-age不为0(以秒为单位)，则代表在这一段时间内，浏览器再次请求此资源时会从缓存中取，而不会再次发送请求到服务器，这种通过对一个资源设置max-age最大有效时间的缓存方式也称为强制缓存。下面是某网站的一个资源的响应头信息。</p>
<p><img src="https://uploader.shimo.im/f/fz4A1SUxzTDevDPo.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/fz4A1SUxzTDevDPo.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>此图的Response Headers信息中，设置了此资源最大的有效时间max-age为315360000s，即在第一次获取这个资源并且持续max-age这么长的时间内，浏览器不需要再向服务器请求这个资源，只需要直接从缓存中就行。此图的General信息中，Status Code状态码为200，并且显示from memory cache，即代表了这个资源是从浏览器缓存中拿取的。另外在响应头中还有一个expires属性，他也指这个资源的过期时间，expires属性是http 1.0被提出的，但后来提出了了http 1.1，其中新增了max-age属性。max-age属性的优先级是要比expires高的，也就是说当这两个属性同时存在时，浏览器会优先考虑max-age的情况。</p>
<h4 id="s-maxage公共缓存"><a href="#s-maxage公共缓存" class="headerlink" title="s-maxage公共缓存"></a>s-maxage公共缓存</h4><p>跟上述max-age非常像的属性时s-maxage，他们都是设置最大的过期时间且提出的时间点也差不多，区别就在于设置的位置不一样。s-maxage是在公共设备上设置(代理服务器)，max-age是在私有设备上设置。我们所使用的自己的电脑浏览器就是私有的设备，再次设备上缓存的你个人的信息只有此设备能获取，在公有设备比如CDN代理服务器上缓存的信息所有用户都可以访问。</p>
<p><img src="https://uploader.shimo.im/f/rqaN4tOVbV8OxLPa.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/rqaN4tOVbV8OxLPa.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>上图是某网一个资源的响应头信息，这条信息设置了s-maxage，同时在加载这个资源的时候General中Status Code状态码为304。那么是什么导致了此种现象的出现呢？我们看一下具体流程。</p>
<p>当浏览器第一次访问某一个资源，会发送请求到源服务器，服务器返回200状态玛，并且在响应头中设置s-maxage。当浏览器第二次访问这个资源就会出现两种情况：</p>
<ul>
<li><p>s-maxage时间没有到，浏览器会向CDN服务器发送请求，并且携带if-modified-since到CND服务器，CDN服务器比对last-modified。如果文件没有修改即两者对应的上，则返回304，并且从CDN缓存中拿取资源返回给浏览器。</p>
</li>
<li><p>如果s-maxage过期了，则CND会向源服务器发送if-modified-since并且比对源服务器文件的last-modified，如果文件没有修改即两者对应的上，则返回304，并且从CND缓存中拿取资源返回给浏览器，如果文件修改了则返回200，由服务器重新发送一份资源给浏览器。</p>
</li>
</ul>
<p>上述两点钟使用了if-modified-since和last-modified即协商缓存策略，之后会详细讲解，读者可以先到后边看一下他俩的含义。</p>
<h4 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a>no-cache</h4><p>当一个资源的响应头中携带了Cache-Control为no-cache，则当这个资源二次加载的时候，会首先服务器确认我的资源的有效性(可以通过后文的if-modified-since或Etag确认)，确认有效才会从缓存中取。确认无效则服务器重新返回给前端一份资源。</p>
<h4 id="must-revalidate"><a href="#must-revalidate" class="headerlink" title="must-revalidate"></a>must-revalidate</h4><p>与no-cache对应的就是must-revalidate。当一个资源的响应头中携带的Cache-Control为must-revalidate，则当这个资源二次加载的时候，会先根据max-age判断资源是否过期，如果过期时间到了，则发送请求到服务器确认此资源的有效性(可以通过后文的if-modified-since或Etag确认)，如果过期时间未到则直接从缓存中取。</p>
<h4 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a>no-store</h4><p>之前了解了Cache-Control中如何设置缓存，如果你不想设置缓存，就是在响应头中设置Cache-Control为no-store即可。</p>
<h3 id="Expires强制缓存"><a href="#Expires强制缓存" class="headerlink" title="Expires强制缓存"></a>Expires强制缓存</h3><p>此属性可以跟Cache-Control属性同时存在代表缓存的过期时间。如果同时存在Expires和max-age属性，浏览器会优先考虑max-age。</p>
<h3 id="强制缓存的缺点"><a href="#强制缓存的缺点" class="headerlink" title="强制缓存的缺点"></a>强制缓存的缺点</h3><p>上述中主要讲了两种强制缓存分别是max-age和Expires。虽然在其设置的有效时间内浏览器不需要再去发起请求，但这恰恰也是强制缓存的缺点。</p>
<p>如果服务端文件已经在缓存有效时间内发生变化，但是前端资源任然没有超过有效时间，那么这就会导致浏览器感知不到服务器文件发生的变化，以至于不能更新到最新的资源。为了解决这个问题，你可以将有效时间设置的稍微短一点，并且配合下文中即将学习的Last-Modified和Etag两种协商缓存进行缓存的优化。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当一个资源缓存的时间超出了其设置的最大缓存时间max-age或者Expires，就会考虑协商缓存的情况。本文主要介绍Last-Modified/If-Modified-Since和Etag/If-None-Match这两种协商缓存策略。</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a><strong>Last-Modified/If-Modified-Since</strong></h3><p>当一个资源在服务端经过修改之后，我们可以通过node的某些函数捕捉到此资源的修改时间，根据这个修改时间可以判断资源是否被修改。Last-Modified/If-Modified-Since就是使用了这一种方式来判断一个文件是否需要被服务器重新发送给浏览器，下边我们来看一下具体流程。</p>
<p>浏览器发起某一个资源的请求到服务器，服务器返回响应，并在响应头中设置last-modified属性，属性值为资源最后修改的时间。当浏览器二次请求这个资源，浏览器会发送请求到服务端，并在请求头中设置if-modified-since属性，属性值为之前响应头中的last-modified的值。服务器拿到响应头中的if-modified-since属性后，比对被请求资源最后的修改时间。如果资源已经被修改即请求头中if-modified-since和资源修改时间比对失败，服务器会重新将这个文件发送给浏览器，状态码为200，同时设置响应头中last-modified为最新的值。如果服务端资源没有被修改即请求头中if-modified-since和资源修改时间比对成功，则返回304状态码，此时浏览器就会去本地缓存中取这个资源，这个过程我们也称之为协商缓存。当强缓存max-age和last-modified协商缓存同时存在时，会优先走强缓存，直到max-age过期时间到了，才会走协商缓存。</p>
<p>Last-Modified/If-Modified-Since虽然能获取最新的资源，但是也存在以下缺点：</p>
<ol>
<li><p>如果文件是在毫秒级别的改变，某些服务器不能获取精确的修改时间。</p>
</li>
<li><p>如果文件修改时间变化了，但文件内容本质没有变，这种情况就会白损耗网络请求。</p>
</li>
</ol>
<p>基于以上缺点，能不能对服务器的某一个文件设置一个精确的标识来告诉浏览器我这个文件到底有没有修改呢？下面我们通过Etag/If-None-Match来解决这个问题。</p>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h3><p>Etag/If-None-Match的请求原理和流程跟Last-Modified/If-Modified-Since一致，唯一不同之处在于Last-Modified/If-Modified-Since保存的是文件的修改时间，这种方式也暴露出一些问题，为了解决这个问题，在我们请求一个资源的时候，浏览器和服务器可以设置Etag/If-None-Match策略，在响应头的Etag属性中设置被请求资源的唯一哈希值，当这个资源被二次加载的时候，只需要在请求头中设置If-None-Match属性，属性值为之前获取的Etag属性值，发送给服务器进行比对。不管是毫秒级别的资源改动还是判断文件内容的变化，哈希值的准确性是比较能保证的。这种Etag/If-None-Match缓存策略跟Last-Modified/If-Modified-Since策略一样，都属于协商缓存。如果两者均存在，则Etag/If-None-Match优先级更高，浏览器会先考虑这种策略。</p>
<h3 id="缓存具体流程图解"><a href="#缓存具体流程图解" class="headerlink" title="缓存具体流程图解"></a>缓存具体流程图解</h3><p>对于各种缓存策略，笔者总结出以下流程图来说明他们之间的关系：</p>
<p><img src="https://uploader.shimo.im/f/SQWOl8UCWhg9SEvm.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/SQWOl8UCWhg9SEvm.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p>在上方的流程图中判断缓存是否过期这一块，我们用一张更加细致的图来展示一下：</p>
<p><img src="https://uploader.shimo.im/f/fBmROXmjJCynbkE3.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/fBmROXmjJCynbkE3.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<h3 id="分级缓存策略"><a href="#分级缓存策略" class="headerlink" title="分级缓存策略"></a>分级缓存策略</h3><p>根据上一栏中的流程图，我们对一个资源二次加载有了更深刻的认识，下面我们就来总结以下分级缓存策略。</p>
<p>当一个资源被二次加载时，首先判断一级缓存中max-age跟s-maxage和Expirse情况。如果一级缓存失效，则考虑二级缓存Etag/If-None-Match和Last-Modified/If-Modified-Since的情况。如果二级缓存也失效，则直接从服务器重新拉取数据，这属于三级缓存。如下图：</p>
<p><img src="https://uploader.shimo.im/f/2ImDGASaaFLr5AOj.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" class="lazyload" data-srcset="https://uploader.shimo.im/f/2ImDGASaaFLr5AOj.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MTkzOTQzOTIsImciOiJUQ3BLM3R2eHFXa1k5OHF5IiwiaWF0IjoxNjE5MzkyNTkyLCJ1IjoyNTQ5NjM0MH0.XgcFP27AK9hzHz_x7M3TIU1B0yLWYQ7AYo3YIcrm9nQ" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<h3 id="Node缓存实战"><a href="#Node缓存实战" class="headerlink" title="Node缓存实战"></a>Node缓存实战</h3><p>之前介绍了缓存的逻辑和流程，下面就用node来逐步实现一下。</p>
<p>新建一个项目，在项目目录中新建服务器app.js文件和静态资源文件夹static。在static文件夹中添加两个静态文件为index.html网页文件和index.jpg图片文件(这个两个文件大家可以自由添加内容)。</p>
<p>在app.js文件中我们要开发一个简单的服务器用来演示整个缓存在服务器中的设置情况，代码如下：</p>
<p>JavaScript</p>
<p>//app.js</p>
<p>const http = require(‘http’);</p>
<p>const url = require(‘url’);</p>
<p>var server = http.createServer((req,res)=&gt;{</p>
<p>   //服务器逻辑</p>
<p>})</p>
<p>server.listen(3000);</p>
<p>通过浏览器我们要获取index.html和index.jpg文件，可以在index.html中引入index.jpg文件，index.html文件代码如下：</p>
<p>HTML, XML</p>
<!DOCTYPE html>

<html lang="en">

<head>

<p>    <meta charset="UTF-8"></p>
<p>    <meta http-equiv="X-UA-Compatible" content="IE=edge"></p>
<p>    <meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
  <title>Document</title>

</head>

<body>

<p>  index.html文件</p>
<p>    <img src="./index.jpg" class="lazyload" data-srcset="./index.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
</body>

</html>

<p>浏览器如果请求index.html文件，在请求到index.html文件之后还会发起第二次请求，请求index.jpg文件。所以我们下面就要在服务器设置这两个文件的请求逻辑，代码如下：</p>
<p>JavaScript</p>
<p>const http = require(‘http’);</p>
<p>const url = require(‘url’);</p>
<p>const fs = require(‘fs’)</p>
<p>var server = http.createServer((req,res)=&gt;{</p>
<p>   //服务器逻辑</p>
<p>  var pathname = url.parse(req.url).pathname;</p>
<p>  var realPath = ‘static’ + pathname;</p>
<p>  fs.readFile(realPath , function(err,data){</p>
<p>​    if(err){</p>
<p>​      res.writeHead(500 , {</p>
<p>​        ‘Content-Type’ : “text/plain”</p>
<p>​      })</p>
<p>​      res.end(“服务器错误”)</p>
<p>​    }else{</p>
<p>​      res.writeHead(200 , {</p>
<p>​        ‘Content-Type’ : “text/plain”</p>
<p>​      })</p>
<p>​      res.end(data)</p>
<p>​    }</p>
<p>  })</p>
<p>})</p>
<p>server.listen(3000);</p>
<p>上述代码运行之后，在浏览器输入<a href="http://#">http://localhost:3000/index.html</a>就可以获取响应结果，但是还需要设置正确的响应头中的Content-Type才能显示正确的效果。所以我们在app.js文件中设置一个函数来返回正确的Content-Type，代码如下：</p>
<p>JavaScript</p>
<p>function getContentType(pathname) {</p>
<p>  var ext = path.parse(pathname).ext;</p>
<p>  switch (ext) {</p>
<p>​    case ‘.html’: {</p>
<p>​      return “text/html”</p>
<p>​    }</p>
<p>​    case “.jpg”: {</p>
<p>​      return ‘img/jpeg’</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>上述代码放在app.js文件中即可，也可外部引入。函数接收pathname参数(再调用函数的时候传入访问的接口名即可)，使用path模块返回传入参数的后缀名，并用switch根据后缀名返回相应的文件类型，此处只涉及到html文件和jpg文件，所以只设置这两项。</p>
<p>下面只需要更改服务器中代码即可，改动如下：</p>
<p>JavaScript</p>
<p>fs.readFile(realPath , function(err,data){</p>
<p>​    if(err){</p>
<p>​      res.writeHead(500 , {</p>
<p>​        ‘Content-Type’ : “text/plain”</p>
<p>​      })</p>
<p>​      res.end(“服务器错误”)</p>
<p>​    }else{</p>
<p>​      res.writeHead(200 , {</p>
<p>​        ‘Content-Type’ : getContentType(pathname)</p>
<p>​      })</p>
<p>​      res.end(data)</p>
<p>​    }</p>
<p>  })</p>
<p>经过上边的设置，现在浏览器再访问<a href="http://#">http://localhost:3000/index.html</a>就可以获取正确的html和jpg文件。大家可以尝试一下。</p>
<h4 id="设置Expirse和max-age"><a href="#设置Expirse和max-age" class="headerlink" title="设置Expirse和max-age"></a><strong>设置Expirse和max-age</strong></h4><p>Expirse需要保存一个文件的最大缓存时间(以毫秒设置)，这个时间是服务器通过响应头设置到前端的，所以服务器首先要设置一个过期时间，并且在现有时间的基础上，在加上这个过期时间。max-age只需要设置这个过期时间即可，他的单位是秒，代码如下：</p>
<p>max-age   s</p>
<p>expirese   时间戳</p>
<p>JavaScript</p>
<p>var server = http.createServer((req,res)=&gt;{</p>
<p>  var pathname = url.parse(req.url).pathname;</p>
<p>  var realPath = ‘static’ + pathname;</p>
<p>  var now = new Date();</p>
<p>  var maxAge = 60; //过期时间为60s</p>
<p>  now.setTime(now.getTime() + maxAge * 1000)</p>
<p>  res.setHeader(‘Expirse’, now.toUTCString());</p>
<p>  res.setHeader(‘Cache-Control’, “max-age=” + maxAge);</p>
<p>  fs.readFile(realPath , function(err,data){</p>
<p>​    if(err){</p>
<p>​      res.writeHead(500 , {</p>
<p>​        ‘Content-Type’ : “text/plain”</p>
<p>​      })</p>
<p>​      res.end(“服务器错误”)</p>
<p>​    }else{</p>
<p>​      res.writeHead(200 , {</p>
<p>​        ‘Content-Type’ : getContentType(pathname)</p>
<p>​      })</p>
<p>​      res.end(data)</p>
<p>​    }</p>
<p>  })</p>
<p>})</p>
<p>上述代码设置了一个变量maxAge为60s，同时获取当前时间，并在当前时间的基础上加上maxAge*1000的时间，通过响应头设置Expirse返回给前端。max-age直接设置过期时间60s。</p>
<p>补充：getTime返回的是当前时间的毫秒数，Expires设置的也是毫秒数，setTime是设置毫秒数，1s=1000ms。</p>
<p>重启node服务器，前端加载出页面后，请打开NetWork，在NetWork中查看html文件和jpg文件的响应头是否设置上了Expirse和max-age，并观察状态码是否为200，以及size请求大小和time请求时间。</p>
<p>如果状态码为200则代表第一次请求文件获取成功。当在你第一次请求之后的60s时间(服务器设置的)内再次刷新页面(二次请求)，观察html和jpg的状态码和请求资源的time和size。可以看到两个文件状态码没有变，但是jpg文件的size变为memary cache(从缓存中取)，time变为0ms，html没有明显变化。这说明jpg文件在有效时间内从缓存中读取，那么html文件为什么没有从缓存中取呢？这其实源自于二次请求的时候html文件的请求头，在这个请求头中设置了max-age=0，则代表html文件的有效时间是0，这其实是浏览器的问题，所以我们不要在意他。此时再看jpg的请求头其实里边是什么都没有的，代表有效时间内而此请求该资源并没有发起向服务器的请求，而是直接从缓存中拿取。</p>
<p>s-maxage的设置逻辑同上，大家可以自由尝试一下。</p>
<h4 id="设置Last-Modified-If-Modified-Since"><a href="#设置Last-Modified-If-Modified-Since" class="headerlink" title="设置Last-Modified/If-Modified-Since"></a>设置Last-Modified/If-Modified-Since</h4><p>Last-Modified/If-Modified-Since主要记录请求文件的修改时间，所以在请求一个文件的时候，我们需要借助fs.stat方法获取这个文件的修改时间，并且将修改时间通过响应头设置到Last-Modified中。之后二次请求这个文件，请求头会自动携带If-Modified-Since属性，属性值为之前的Last-Modified的值，传递给服务器进行确认。如果比对成功则返回304，如果比对失败则返回200并且服务器重新发送一个最新的资源给前端，代码如下：</p>
<p>JavaScript</p>
<p>var server = http.createServer((req,res)=&gt;{</p>
<p>  var pathname = url.parse(req.url).pathname;</p>
<p>  var realPath = ‘static’ + pathname;</p>
<p>  if(pathname == ‘/favicon.ico’){</p>
<p>​    return</p>
<p>  }</p>
<p>  fs.stat(realPath, function (err, stats) {</p>
<p>​    var lastTime = stats.mtime.toUTCString();</p>
<p>​    res.setHeader(‘last-Modified’, lastTime);</p>
<p>​    fs.readFile(realPath, function (err, data) {</p>
<p>​      if (err) {</p>
<p>​        res.writeHeader(500, {</p>
<p>​          ‘Content-Type’: “text/plain;charset=utf-8”</p>
<p>​        })</p>
<p>​        res.end(“服务器出错了”)</p>
<p>​      } else {</p>
<p>​        if(req.headers[‘if-modified-since’] &amp;&amp; req.headers[‘if-modified-since’] == lastTime){</p>
<p>​          res.writeHead(304 , ‘Not Midified’);</p>
<p>​        }</p>
<p>​        else{</p>
<p>​          res.writeHead(200, {</p>
<p>​            ‘Content-Type’: getContentType(pathname)</p>
<p>​          })</p>
<p>​          res.write(data)</p>
<p>​        }</p>
<p>​        res.end()</p>
<p>​      }</p>
<p>​    })</p>
<p>  })</p>
<p>})</p>
<p>运行此代码，观察浏览器中两个资源的响应头中是否含有last-Modified字段，如果有代表设置成功。刷新浏览器二次请求服务器，观察响应头的变化。可以看到html文件状态码为304，即服务器告诉浏览器资源并没有过期，请从缓存中取。jpg文件状态码为200，size为memory cache代表来自缓存。</p>
<p>读者可以自行试验一下，把后端服务器中的静态文件修改之后在刷新浏览器之后的效果。Etag和Last-Modified原理一样，有兴趣大家可以自行实现。</p>
<h4 id="强制缓存和协商缓存结合"><a href="#强制缓存和协商缓存结合" class="headerlink" title="强制缓存和协商缓存结合"></a>强制缓存和协商缓存结合</h4><p>在业务逻辑中，我们经常要将强缓存和协商缓存一起使用，即将上述两部分逻辑综合一下，完整代码如下：</p>
<p>JavaScript</p>
<p>const http = require(‘http’);</p>
<p>const url = require(‘url’);</p>
<p>const fs = require(‘fs’);</p>
<p>const path = require(‘path’);</p>
<p>function getContentType(pathname) {</p>
<p>  var ext = path.parse(pathname).ext;</p>
<p>  switch (ext) {</p>
<p>​    case ‘.html’: {</p>
<p>​      return “text/html”</p>
<p>​    }</p>
<p>​    case “.jpg”: {</p>
<p>​      return ‘img/jpeg’</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>var server = http.createServer((req,res)=&gt;{</p>
<p>  var pathname = url.parse(req.url).pathname;</p>
<p>  var realPath = ‘static’ + pathname;</p>
<p>  if(pathname == ‘/favicon.ico’){</p>
<p>​    return</p>
<p>  }</p>
<p>  var now = new Date();</p>
<p>  var maxAge = 60; //一个小时的过期时间</p>
<p>  now.setTime(now.getTime() + maxAge)</p>
<p>  res.setHeader(‘Expirse’, now.toUTCString());</p>
<p>  res.setHeader(‘Cache-Control’, “max-age=” + maxAge);</p>
<p>  fs.stat(realPath, function (err, stats) {</p>
<p>​    var lastTime = stats.mtime.toUTCString();</p>
<p>​    res.setHeader(‘last-Modified’, lastTime);</p>
<p>​    fs.readFile(realPath, function (err, data) {</p>
<p>​      if (err) {</p>
<p>​        res.writeHeader(500, {</p>
<p>​          ‘Content-Type’: “text/plain;charset=utf-8”</p>
<p>​        })</p>
<p>​        res.end(“服务器出错了”)</p>
<p>​      } else {</p>
<p>​        if(req.headers[‘if-modified-since’] &amp;&amp; req.headers[‘if-modified-since’] == lastTime){</p>
<p>​          res.writeHead(304 , ‘Not Midified’);</p>
<p>​        }</p>
<p>​        else{</p>
<p>​          res.writeHead(200, {</p>
<p>​            ‘Content-Type’: getContentType(pathname)</p>
<p>​          })</p>
<p>​          res.write(data)</p>
<p>​        }</p>
<p>​        res.end()</p>
<p>​      }</p>
<p>​    })</p>
<p>  })</p>
<p>})</p>
<p>server.listen(3000);</p>
<p>对于前端的缓存我们就介绍到这。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://example.com/2021/04/26/%E9%9D%A2%E8%AF%95/>http://example.com/2021/04/26/%E9%9D%A2%E8%AF%95/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-05-03T17:18:24+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：May 3, 2021</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/2021/04/26/%E9%9D%A2%E8%AF%95/&title= - Z.X's Blog&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://example.com/2021/04/26/%E9%9D%A2%E8%AF%95/&title= - Z.X's Blog&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/2021/04/26/%E9%9D%A2%E8%AF%95/&title= - Z.X's Blog&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2021/04/27/Promise/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i></p>
          <p class='content'>async/await PromisePromise之前的时代
12345678910111213getUser(function(response)&#123;    getGroup(res...</p>
        </a>
      
      
        <a class='next' href='/2021/04/24/post%E5%92%8Cget%E7%9A%84%E5%8C%BA%E5%88%AB/'>
          <p class='title'><i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'></p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BH5%E6%A0%87%E7%AD%BE%E5%92%8C%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">你用过哪些H5标签和特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#meta%E4%B8%ADviewport%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-text">meta中viewport是做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-text">HTML语义化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">HTML全局属性有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">src与href的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%80%E5%A4%9A%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">网络中使用最多的图片格式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#link-%E5%B9%B6%E8%A1%8C-%E5%92%8C-import-%E4%B8%B2%E8%A1%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">link(并行)和@import(串行)的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">垂直居中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">水平居中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#opacity%E5%92%8Crgba%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E5%8C%BA%E5%88%AB"><span class="toc-text">opacity和rgba透明效果区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E8%AE%BE%E7%BD%AEfloat%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">行内元素设置float之后会发生什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#px-rpx-em-rem-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">px&#x2F;rpx&#x2F;em&#x2F;rem&#x2F;vw&#x2F;vh的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%8A%A8%E7%94%BB%EF%BC%8C%E4%BD%A0%E8%AE%A4%E4%B8%BA%E6%AF%94%E8%BE%83%E6%B5%81%E7%95%85%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">手写一个动画，你认为比较流畅的最大时间间隔为多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">盒模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">怪异盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">标准盒模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">css3新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block%E5%85%83%E7%B4%A0%E5%92%8Cinline%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">block元素和inline元素的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E7%BB%A7%E6%89%BF%E3%80%81%E5%B1%82%E5%8F%A0"><span class="toc-text">CSS继承、层叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%8F%A0%E6%80%A7"><span class="toc-text">层叠性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC"><span class="toc-text">BFC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBFC"><span class="toc-text">什么是BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99"><span class="toc-text">BFC布局规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9FBFC"><span class="toc-text">怎么产生BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">BFC的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">数组扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce%E5%AE%9E%E7%8E%B0"><span class="toc-text">reduce实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-amp-split"><span class="toc-text">toString&amp;split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-amp-split"><span class="toc-text">join &amp; split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">数组去重</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%8E%BB%E9%87%8D"><span class="toc-text">Set去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%B3%95%E5%8E%BB%E9%87%8D"><span class="toc-text">指针法去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8indexOf%E5%8E%BB%E9%87%8D"><span class="toc-text">利用indexOf去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8includes%E5%8E%BB%E9%87%8D"><span class="toc-text">利用includes去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8filter%E5%8E%BB%E9%87%8D"><span class="toc-text">使用filter去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">数组常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-isArray"><span class="toc-text">Array.isArray()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-of"><span class="toc-text">Array.of()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-from"><span class="toc-text">Array.from()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop"><span class="toc-text">pop()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shift"><span class="toc-text">shift()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push"><span class="toc-text">push()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unshift"><span class="toc-text">unshift()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-text">reverse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice"><span class="toc-text">splice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-text">sort()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copyWithin"><span class="toc-text">copyWithin()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill"><span class="toc-text">fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-text">slice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concat"><span class="toc-text">concat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf"><span class="toc-text">indexOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lastIndexOf"><span class="toc-text">lastIndexOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#includes"><span class="toc-text">includes()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-text">forEach()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#some"><span class="toc-text">some()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#every"><span class="toc-text">every()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-text">filter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-text">map()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-text">reduce()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flat"><span class="toc-text">flat()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-BOM"><span class="toc-text">DOM&#x2F;BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-text">BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM"><span class="toc-text">DOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#es6%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">es6新增的数据类型有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var%E3%80%81let%E3%80%81const%E5%8C%BA%E5%88%AB"><span class="toc-text">var、let、const区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-text">async&#x2F;await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">promise的用法和几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in%E5%92%8Cfor-of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">for in和for of的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-text">严格模式和普通模式区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">递归实现深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">JSON实现深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async%E5%92%8Cdefer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">async和defer的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6"><span class="toc-text">JS事件轮询机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"><span class="toc-text">防抖与节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-text">节流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99ajax%E5%B0%81%E8%A3%85"><span class="toc-text">手写ajax封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">事件代理(事件委托)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89"><span class="toc-text">事件捕捉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-1"><span class="toc-text">事件代理(事件委托)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">阻止事件冒泡和默认事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-text">原型、原型链、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">发布订阅者模式和观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89"><span class="toc-text">观察者模式（Observer Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88Pub-Sub-Pattern%EF%BC%89"><span class="toc-text">发布订阅模式（Pub-Sub Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">观察者模式和发布订阅模式有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">观察者模式实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">发布订阅模式实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind"><span class="toc-text">call、apply、bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">call基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">apply基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">bind基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99bind%E5%87%BD%E6%95%B0"><span class="toc-text">手写bind函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95"><span class="toc-text">冒泡算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">JS中栈和堆的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">js中的变量类型与栈和堆的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-assign"><span class="toc-text">Object.assign()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E5%9C%BA%E6%99%AF"><span class="toc-text">常见跨域场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cros%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-text">cros跨域及解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsop%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-text">jsop跨域及解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F-%E6%9C%80%E5%B8%B8%E8%A7%81"><span class="toc-text">proxy代理跨域(最常见)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6"><span class="toc-text">node事件轮询机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">node中的线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">什么是多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">多线程的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%88%A9%E6%96%B9%E9%9D%A2"><span class="toc-text">多线程的不利方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">多线程与单线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">node实现多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-1-0%E5%92%8Chttp-2-0"><span class="toc-text">http 1.0和http 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-1-0%E5%92%8Chttp1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">http 1.0和http1.1的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E3%80%81https%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">http、https的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#event%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97"><span class="toc-text">event事件模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#events%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">events模块与发布订阅者模式的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">http报文格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87request"><span class="toc-text">请求报文request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87response"><span class="toc-text">响应报文response</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">DNS域名系统，简单描述其工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E4%B8%AAjs%E8%84%9A%E6%9C%AC%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-text">如何避免多个js脚本发生冲突？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#state"><span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8setState%EF%BC%9F"><span class="toc-text">为什么使用setState？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0state%EF%BC%9F"><span class="toc-text">setState如何更新state？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86setState%E8%AE%BE%E8%AE%A1%E6%88%90%E5%BC%82%E6%AD%A5%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么要将setState设计成异步的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B9%8B%E5%90%8E%E7%9A%84state"><span class="toc-text">如何获取异步更新之后的state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0state"><span class="toc-text">setState什么情况下会同步更新state</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">react更新机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">key的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hooks"><span class="toc-text">Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hooks%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">hooks中的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-text">react中的diff算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-text">传统的diff算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%B8%AD%E7%9A%84diff"><span class="toc-text">react中的diff</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%ADaxios%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F"><span class="toc-text">vue中axios如何设置拦截器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">vue更新机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E7%AE%80%E4%BB%8B"><span class="toc-text">webpack简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loader%E5%92%8CPlugin%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-text">Loader和Plugin是做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84loader%E6%9C%89%E5%93%AA%E4%BA%9B-%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">常见的loader有哪些 ？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">常见的Plugin有哪些？解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">webpack热更新原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">webpack构建项目的流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">为什么要进行前端优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAURl%E4%BB%8E%E5%8F%91%E9%80%81%E5%88%B0%E8%BF%94%E5%9B%9E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一个URl从发送到返回都经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">前端可以做哪些方面的优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-text">HTML页面加载渲染过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E3%80%81localStroage%E3%80%81sessionStorage%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">cookie、localStroage、sessionStorage的作用和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-text">浏览器内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-text">HTTP请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E5%AE%89%E5%85%A8"><span class="toc-text">Web安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5"><span class="toc-text">sql注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xss%E9%98%B2%E8%8C%83"><span class="toc-text">xss防范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xss%E4%B8%8Ecsrf%E5%8C%BA%E5%88%AB"><span class="toc-text">xss与csrf区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7"><span class="toc-text">渐进增强和优雅降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9F%AD%E8%BD%AE%E8%AF%A2"><span class="toc-text">长轮询短轮询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%BD%AE%E8%AF%A2"><span class="toc-text">短轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-text">长轮询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Control%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-text">Cache-Control缓存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#max-age%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-text">max-age强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#s-maxage%E5%85%AC%E5%85%B1%E7%BC%93%E5%AD%98"><span class="toc-text">s-maxage公共缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#no-cache"><span class="toc-text">no-cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#must-revalidate"><span class="toc-text">must-revalidate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#no-store"><span class="toc-text">no-store</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expires%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-text">Expires强制缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">强制缓存的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Last-Modified-If-Modified-Since"><span class="toc-text">Last-Modified&#x2F;If-Modified-Since</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Etag-If-None-Match"><span class="toc-text">Etag&#x2F;If-None-Match</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-text">缓存具体流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-text">分级缓存策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E7%BC%93%E5%AD%98%E5%AE%9E%E6%88%98"><span class="toc-text">Node缓存实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEExpirse%E5%92%8Cmax-age"><span class="toc-text">设置Expirse和max-age</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AELast-Modified-If-Modified-Since"><span class="toc-text">设置Last-Modified&#x2F;If-Modified-Since</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E7%BB%93%E5%90%88"><span class="toc-text">强制缓存和协商缓存结合</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


  


</aside>



		  
		  <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=false;
  pdata.postTitle="";
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  // header 这里无论是否开启pjax都需要
  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
  
    // cover
    var cover_wrapper=document.querySelector('.cover-wrapper');
    
    cover_wrapper.id="none";
    cover_wrapper.style.display="none";
    
  
</script>

        </div>
        
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


        <a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
      </div>
    </div>
    <div>
      <script>
/************这个文件存放不需要重载的全局变量和全局函数*********/
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/******************** Pjax ********************************/
function VPjax(){
	this.list=[] // 存放回调函数
	this.start=()=>{
	  for(var i=0;i<this.list.length;i++){
		this.list[i].run();
	  }
	}
	this.push=(fn,name)=>{
		var f=new PjaxItem(fn,name);
		this.list.push(f);
	}
	// 构造一个可以run的对象
	function PjaxItem(fn,name){
		// 函数名称
		this.name = name || fn.name
		// run方法
		this.run=()=>{
			fn()
		}
	}
}
volantis.pjax={}
volantis.pjax.method={
	complete: new VPjax(),
	error: new VPjax(),
	send: new VPjax()
}
volantis.pjax={
	...volantis.pjax,
	push: volantis.pjax.method.complete.push,
	error: volantis.pjax.method.error.push,
	send: volantis.pjax.method.send.push
}
/********************脚本懒加载函数********************************/
// 已经加入了setTimeout
function loadScript(src, cb) {
	setTimeout(function() {
		var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
		var script = document.createElement('script');
		script.setAttribute('type','text/javascript');
		if (cb) script.onload = cb;
		script.setAttribute('src', src);
		HEAD.appendChild(script);
	});
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
  };
  $(function () {
    SCload_fancybox();
  });
  function Pjax_SCload_fancybox(){
	if (typeof $.fancybox == "undefined") {
	 SCload_fancybox();
    } else {
	 pjax_fancybox();
    }
  }
  volantis.pjax.push(Pjax_SCload_fancybox)
  volantis.pjax.send(()=>{
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
  },'fancybox')
</script>


<!-- internal -->




<script>
  function loadIssuesJS() {
    if ($(".md").find(".issues-api").length == 0) return;
	
	  loadScript('/js/issues.js');
	
  };
  $(function () {
    loadIssuesJS();
  });
  volantis.pjax.push(()=>{
	if (typeof IssuesAPI == "undefined") {
	  loadIssuesJS();
	}
  },"IssuesJS")
</script>



  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: [],
	maxRPS: 5,
	hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>











  
  
<script src="/js/valine.js"></script>


<script>
  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;
    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";
    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    var valine = new Valine();
    valine.init(Object.assign({"path":null,"placeholder":"快来评论吧~","appId":null,"appKey":null,"meta":["nick","mail","link"],"requiredFields":["nick","mail"],"enableQQ":true,"recordIP":false,"avatar":"robohash","pageSize":10,"lang":"zh-cn","highlight":true,"mathJax":false}, {
      el: '#valine_container',
      path: path,
      placeholder: pagePlaceholder,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps,
    }))
  }
  $(function () {
    pjax_valine();
  });
  volantis.pjax.push(pjax_valine);
</script>






  
<script src="/js/app.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('/js/search/hexo.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://example.com' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://example.com' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://example.com' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "user-color-scheme";
const rootElementDarkModeAttributeName = "data-user-color-scheme";

const setLS = (k, v) => {
    localStorage.setItem(k, v);
};

const removeLS = (k) => {
    localStorage.removeItem(k);
};

const getLS = (k) => {
    return localStorage.getItem(k);
};

const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};

const validColorModeKeys = {
  dark: true,
  light: true,
};

const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);

  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};

const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};

/**
 * get target mode
 */
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);

  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};

/**
 * bind click event for toggle button
 */
var btn=$("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn");
function bindToggleButton() {
    btn.on('click',(e) => {
      const mode = toggleCustomDarkMode();
      applyCustomDarkModeSettings(mode);
    });
}

applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", bindToggleButton);
volantis.pjax.push(bindToggleButton);
volantis.pjax.send(()=>{
	btn.unbind('click');
},'toggle-mode-btn-unbind');
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->

 
	   
	    


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）

      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
		// 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
		volantis.pjax.method.complete.start();
      } catch (e) {
        console.log(e);
      }
    });

    document.addEventListener('pjax:error', function (e) {
	  // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.error.start();
      window.location.href = e.triggerElement.href;
    });
</script>
 
	  
    </div>
  </body>
</html>
